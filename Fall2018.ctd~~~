<?xml version="1.0" ?>
<cherrytree>
	<node custom_icon_id="0" foreground="" is_bold="True" name="CIS505" prog_lang="plain-text" readonly="False" tags="" ts_creation="1534945775.44" ts_lastsave="1534945775.44" unique_id="1">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="August 22, 2018" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1534945793.06" ts_lastsave="1535117790.01" unique_id="2">
			<rich_text weight="heavy">Intro to SML</rich_text>
			<rich_text>

</rich_text>
			<rich_text underline="single">Language Paradigms</rich_text>
			<rich_text>
• ways of expressing computation
• main paradigms
   ◇ imperative
      ▪ how you program
      ▪ C/C++
   ◇ functional
      ▪ how you think about problems
      ▪ more abstract
   ◇ others
      ▪ object-oriented
      ▪ logical
      ▪ algebraic
   ◇ don't need to use one paradigm continuously
      ▪ some problems more suited to one paradim or another

• Imperative
   ◇ computation expressed by modification of an </rich_text>
			<rich_text style="italic">explicit</rich_text>
			<rich_text> store
   ◇ intermediate results held in store
   ◇ iteration-based control
• Functional
   ◇ computation expressed by function application and composition
   ◇ no explicit store
   ◇ intermediate results passed directly into other functions
   ◇ recursion-based control
   ◇ key characteristic (guide rope)
      ▪ absence of side effects
      ▪ function doesn't rely on data outside the current function
      ▪ data outside function is not modified

Why Functional programming?
• advanced features
• high-level
• clean
   ◇ easier to prove correct programming
• it's not java
   ◇ good way to learn a radically different language

Why SML?
• well-understood foundations
   ◇ 40-year-old language
   ◇ quirks are well-known
   ◇ most studied theory/foundations
• well-designed
   ◇ language creator received a Turing award partly for work on language
• versioning
   ◇ several concurrent versions</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Statements vs Expressions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1534947264.93" ts_lastsave="1534947515.52" unique_id="3">
				<rich_text>
Definitions:
• Statement: what code does
• Expression: what code is

Statements
• What code </rich_text>
				<rich_text style="italic">does</rich_text>
				<rich_text>
• Construct is evaluated only for the effect
• statement-oriented languages
   ◇ Pascal, C/C++, COBOL, etc
   ◇ many commonly-used low-end languages

Expressions
• something you do to get a value
• describe what code </rich_text>
				<rich_text style="italic">is</rich_text>
				<rich_text>
• construct evaluated to yield a value
• pure expressions render </rich_text>
				<rich_text underline="single">no side effects</rich_text>
				<rich_text>
• expression-oriented languages
   ◇ Scheme, ML, Lisp, Haskell

If it's unclear:
• check against guide rope
• is construct evaluated for value or side-effect?</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="SML Intro" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535117790.01" ts_lastsave="1536328692.04" unique_id="11">
			<rich_text>
Basic Expressions
• constants (literals)
• variable references
• function applications
• conditional expressions

Constants
• Integers
• Reals
   ◇ potentially infinite sequences of decimals
• Booleans
   ◇ true and false
• Strings
   ◇ written with double-quotes
• Characters
   ◇ written with `#` in front of value

String Operations
• concatenate with `^`

Comparison Operators
• equality written with single =
• cannot use equality with reals
   ◇ reals are potentially infinite sequences of decimals
   ◇ can check greater than or less than

Booleans
• not
• andalso
• orelse
• not commutative, as “short circuit” operations
   ◇ eg `(1 &lt; 4) orelse ((5 div 0) &lt; 2);`
      ▪ second operation won't execute at all

Typing Issues
• strong typing
   ◇ strong/weak typing = how strict the typing is
   ◇ each value has exactly one type
   ◇ eg. 12 is an int but not a real
   ◇ explicit converstions are necessaryd801d0a3f1384fb414fd8ab56b822492
• static typing
   ◇ satic/dynamic = when types are checked
   ◇ type-checking at compile time
• no notion of a Null type

Character Coercions
• char to int: ord()
   ◇ eg ord(#&quot;0&quot;) = 48
• int to char: chr()
   ◇ eg chr(48) = #&quot;0&quot;
• char to string: str()

Identifier rules
• two classes of identifiers
   ◇ alphanumeric
   ◇ symbolic</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Complex Values" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535376720.06" ts_lastsave="1535378932.66" unique_id="15">
				<rich_text>
Tuple
• fixed-size ordered collection of two or more values
• access tuple values with #1(tuple_name);
   ◇ tuples are 1-indexed
• single-value tuples are just values
   ◇ tuples are immutable
• can nest tuples within each other
   ◇ able to access with #1(#1(parent));

Lists
• collection of values of the </rich_text>
				<rich_text style="italic">same</rich_text>
				<rich_text> type
• can nest lists
• list with one element is still a list
   ◇ different than the element on its own
• list with no elements can be any type
   ◇ list of type “'a list”
• concatenate lists with `@`
   ◇ e.g. [1,4,7]@[2,5]
   ◇ concatenating with empty list provides same list type
• lists are 0-indexed

Tuples vs Lists
• Lists:
   ◇ always same type
   ◇ possibly different length
   ◇ work with individual items in list
      ▪ want to iterate over items in the list
• Tuples
   ◇ always same length
   ◇ possibly different types
   ◇ work with list as a coherent unit

List Operations
</rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text>
</rich_text>
				<table char_offset="905" col_max="90" col_min="40">
					<row>
						<cell>empty list</cell>
						<cell>[]</cell>
						<cell>`a list</cell>
						<cell>list of any type</cell>
					</row>
					<row>
						<cell>head</cell>
						<cell>hd</cell>
						<cell>'a list -&gt; 'a</cell>
						<cell>returns first element of list</cell>
					</row>
					<row>
						<cell>tail</cell>
						<cell>tl</cell>
						<cell>`a list -&gt; 'a list</cell>
						<cell>returns all but first</cell>
					</row>
					<row>
						<cell>append</cell>
						<cell>@</cell>
						<cell>`a list * `a list -&gt; `a list</cell>
						<cell>combines two lists</cell>
					</row>
					<row>
						<cell>cons</cell>
						<cell>::</cell>
						<cell>`a * `a list -&gt; `a list</cell>
						<cell>adds single element to list</cell>
					</row>
					<row>
						<cell>operation</cell>
						<cell>command</cell>
						<cell>result</cell>
						<cell>explanation</cell>
					</row>
				</table>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Functions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535378022.3" ts_lastsave="1535723018.13" unique_id="16">
				<rich_text>
Defining Functions
• use `fn` keyword
   ◇ val inc = fn (x) =&gt; x + 1;
   ◇ fn creates function but doesn't bind it to a value
      ▪ similar to lambda functions
• can also write with `fun`
   ◇ fun inc(x) = x + 1;
   ◇ creates function and binds it to value

Function Values
• anonymous functions
   ◇ fn x =&gt; x + 2;
      ▪ has no name
• can be tuple components
   ◇ val p = (fn(x,y) =&gt; x+y, fn(x,y) =&gt; x - y);
   ◇ #1(p)(2,3)
      ▪ 5
   ◇ #2(p)(2,3)
      ▪ ~1

functions are values
• higher-order function
   ◇ processes other functions
   ◇ takes function as input, or returns function as output
• functions are first-class citizens
• like any value, they can be
   ◇ placed in tuples
   ◇ placed in lists
   ◇ passed as function arguments
   ◇ returned as function results

Variable Scope
• variables by default are global
• once variable is bound in function, value is kept
   ◇ if variable is changed after function is defined, old value is used
   ◇ new definitions of the same variable don't overwrite old definitions
      ▪ they shadow the old definitions
• old definitions may still be referred to
   ◇ ML is </rich_text>
				<rich_text style="italic">statically scoped</rich_text>
				<rich_text>
• for efficiency, old definitions may be garbage collected if they are not referred to

Multi-argument functions
• In reality, each SML function takes one argument and returns one result value
• if need to pass multiple arguments, generally package args in a tuple
• if a function takes n argument, say that it has </rich_text>
				<rich_text style="italic">arity</rich_text>
				<rich_text> n
• implementation
   ◇ can we do it without tuples or lists?
   ◇ yes, use higher-order functions
   ◇ nest functions within each other
   ◇ fun add3 x =&gt; fn y =&gt; fn z =&gt; x + y + z;

Interpreting function types
• look closely at types
   ◇ fn : int -&gt; int -&gt; int -&gt; int
      ▪ fn : int -&gt; (int -&gt; (int -&gt; int))
      ▪ fn : (int -&gt; int) -&gt; (int -&gt; int)
   ◇ first two describe function that
      ▪ takes int as arg and returns function of type int -&gt; int -&gt; int</rich_text>
				<node custom_icon_id="0" foreground="" is_bold="False" name="Function composition" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535723018.13" ts_lastsave="1535723217.57" unique_id="25">
					<rich_text>
Using the “o” keyword
• combines two functions
• eg: val add8 = add3 o add5

user-defined function
• my_o
• fun my_o g f = fn x +&gt; g(f(x))
   ◇ fn: ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b</rich_text>
				</node>
				<node custom_icon_id="0" foreground="" is_bold="False" name="Functions on Lists" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535723217.57" ts_lastsave="1536329381.07" unique_id="26">
					<rich_text>
Outline
• recursive functions follow the structure of inductively-defined data
• using lists as our example, we study
   ◇ inductive definitions (specifying data)
   ◇ recursive functions (processing data)
   ◇ frequent function templates
• inductive definition
   ◇ base element + some way of repeatedly modifying elements to produce new ones
• recursive funtion
   ◇ function that calls itself repeatedly until it reaches a base case


Specifying Types/Sets
• Extensional
   ◇ {n | n is a multiple of 3}
   ◇ gives information about the item of a set
   ◇ doesn't say how to construct the set
• Intensional
   ◇ let S be the smallest set of natural numbers satisfying
      ▪ 0 ∈ S
      ▪ x + 3 ∈ S whenever x ∈ S
   ◇ why require the smallest solution?
      ▪ previous specifications could result in multiple sets
         - {0,3,6,9...}
         - {0,1,3,4,6,7,...}


BNF Inductive Specifications
• Integer lists:
   ◇ &lt;int-list&gt; ::= nil | &lt;int&gt; :: &lt;int-list&gt;
   ◇ ex: 1 :: 2 :: 3 :: nil ≡ [1,2,3]
   ◇ given an int list, you can further construct a list by pre-pending an integer or nil
• note:
   ◇ recursion in grammar
   ◇ each use of :: increases list length by 1


Approximating Recursion
• using BNF grammar
• write family of functions list_sum_i, with i being the length of the arg
   ◇ list_sum_1(ls)
   ◇ list_sum_2(ls)
   ◇ etc
• put them together
   ◇ fun list_sum_0(ls) = 0;
   ◇ fun list_sum_1(ls) = hd(ls) + list_sum_0(tl(ls));
   ◇ fun list_sum_2(ls) = hd(ls) + list_sum_1(tl(ls));
• recursively:
   ◇ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
   ◇ clearer by ML patterns
      ▪ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
   ◇ or even better
      ▪ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
• Template
   ◇ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>


Map, Filter, and Fold
• How can I
   ◇ add one to each item of a list?
      ▪ add1(n::ns) = (n + 1) :: (add1 ns)
   ◇ select elements greater than 5?
      ▪ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
   ◇ append two lists?
      ▪ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
      ▪ nil is left identity: append(nil x) = x for all lists x


Map
• add one to each element of a list
• </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
• generalization: apply an arbitrary funtion to each element
   ◇ map is built-in function
   ◇ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
   ◇ apply function to first object then recursively apply to rest of list
   ◇ type of function
      ▪ fn : ('a -&gt; ‘b) -&gt; ’a list -&gt; 'b list
   ◇ instantiation: add one to each element
      ▪ val my_list_inc = list_map (fn x =&gt; x + 1);
   ◇ instantiation: square each element
      ▪ val square_list = list_map (fn x =&gt; x * x);


Filter
• selecting only elements greater than five (see above)
• function: select using arbitrary predicate
   ◇ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
   ◇ is type
      ▪ (a' -&gt; bool) -&gt; ‘a list -&gt; ’a list


Foldr
• “folding” all elements by adding them
• </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
• generalization
   ◇ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
   ◇ f is function to apply
   ◇ e is default base case
   ◇ x::xs is list to apply foldr to
   ◇ type of foldr
      ▪ ('a * ‘b -&gt; ’b) -&gt; ‘b -&gt; ’a list -&gt; 'b
• instantiation: list_sum
   ◇ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
• instantiation: my_identity
   ◇ my_id = foldr op:: []
      ▪ fn x =&gt; x
• instantiation: my_append
   ◇ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>


Foldl
• recall foldr, processing input from </rich_text>
					<rich_text style="italic">right</rich_text>
					<rich_text>
• now consider foldl, processing input from left:
   ◇ </rich_text>
					<rich_text justification="left"></rich_text>
					<rich_text>
   ◇ f is function to apply
   ◇ e is default empty case
• type
   ◇ ('a * ‘b -&gt; ’b) -&gt; ‘b -&gt; ’a list -&gt; 'b
• example
   ◇ foldl op:: nil xs
   ◇ reverses a list


Summary
• map applies arbitrary function to each element
• filter selects elements form a list using an arbitrary predicate
• fold reduces a list to a single element</rich_text>
					<codebox char_offset="1525" frame_height="80" frame_width="230" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun list_sum(ls) = 
    if ls = nil
        then 0
        else hd(ls) + list_sum(tl(ls)</codebox>
					<codebox char_offset="1563" frame_height="80" frame_width="240" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun list_sum(ls) =
    case ls of
        nil =&gt; 0
        (n :: ns) =&gt; n + list_sum(ns);</codebox>
					<codebox char_offset="1593" frame_height="40" frame_width="360" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun list_sum(nil) = 0 | list_sum(n::ns) = n + list_sum(ns);</codebox>
					<codebox char_offset="1611" frame_height="40" frame_width="240" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun list_rec(nil) = ....
|    list_rec(n :: ns) = ... list_rec(ns)...</codebox>
					<codebox char_offset="1774" frame_height="90" frame_width="360" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="plain-text" width_in_pixels="True">fun gt_five(nil) = nil
|   gt_five(n::ns) =
        if n &gt; 5
            then n::gt_five(ns)
            else gt_five(ns);</codebox>
					<codebox char_offset="1807" frame_height="80" frame_width="360" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="plain-text" width_in_pixels="True">append(nil, ys) = ys
|   append(x::xs, ys) = x::append(xs ys);</codebox>
					<codebox char_offset="1917" frame_height="47" frame_width="375" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="plain-text" width_in_pixels="True">fun list_inc(nil) = nil
|   list_inc(n::ns) = (n+1)::list_inc(ns);</codebox>
					<codebox char_offset="2015" frame_height="40" frame_width="360" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="plain-text" width_in_pixels="True">fun list_map f nil = nil
|   list_map f (n::ns) = f(n) :: list_map f ns;</codebox>
					<codebox char_offset="2463" frame_height="70" frame_width="360" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="plain-text" width_in_pixels="True">fun list_filter p nil = nil
|   list_filter p (n :: ns) =
        if p(n) then n::list_filter p ns
        else list_filter p ns;</codebox>
					<codebox char_offset="2571" frame_height="40" frame_width="360" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="plain-text" width_in_pixels="True">fun list_sum(nil) = 0
|   list_sum(n::ns) = n + list_sum(ns);</codebox>
					<codebox char_offset="2595" frame_height="40" frame_width="360" highlight_brackets="True" show_line_numbers="True" syntax_highlighting="plain-text" width_in_pixels="True">fun foldr f e nil = e
|   foldr f e (x::xs) = f(x, (foldr f e xs));</codebox>
					<codebox char_offset="2787" frame_height="30" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">list_sum = foldr op+ 0 xs;</codebox>
					<codebox char_offset="2895" frame_height="24" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun my_append xs ys = foldr op:: ys xs;</codebox>
					<codebox char_offset="3004" frame_height="48" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun ofldl f e nil = e
|   foldl f e (x::sx) = foldl f (f(x,e)) xs</codebox>
				</node>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Currying" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535551178.64" ts_lastsave="1535552127.62" unique_id="20">
				<rich_text>
Definition
• take an argument with several arguments and make it take them one at a time

Instantiating Curried Functions
• currying is useful because it allows us to create partially instantiated functions
   ◇ functions where some (but not all) args are supplied</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Polymorphism" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535552127.62" ts_lastsave="1535552128.51" unique_id="21">
				<rich_text>
poly = many, morph = form</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Homework Review" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536328692.04" ts_lastsave="1536586596.31" unique_id="30">
			<rich_text></rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Lab 2" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536328697.76" ts_lastsave="1537193310.79" unique_id="31">
				<rich_text>fun add_squares [] = 0
|   add_squares (x :: sx) =
        (x * x) + (add_squares xs);
        
fun add_squares' sx = foldr op+ 0 (map (fn x =&gt; x * x) xs);

fun mult_nonzero [] = 1
|   mult_nonzero (x :: xs) =
        if x = 0
        then mult_nonzero xs
        else x * mult_nonzero xs;
        
fun mult_nonzero' sx = foldr op* 1 (List.filter (fn x =&gt; x &lt;&gt; 0) xs);

fun half_evens [] = []
|   half_evens (x :: sx) =
        if x mod 2 = 0
        then (x div 2) : (half_evens xs)
        else half_evens xs;
        
fun half_evens' xs = map (fn x =&gt; x div 2) (List.filter (fn x =&gt; x mod 2 = 0) xs)</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Lab 3" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1537193310.8" ts_lastsave="1537797256.82" unique_id="39">
				<rich_text>
Overview
• tree manipulation
• learn to represent and modify trees


Review
• use cases for depth
   ◇ Leaf x =&gt; (0, [x])
   ◇ Node (bt1, bt2) =&gt; let
      ▪ val (depth1, deepest1) = deepest bt1
      ▪ val (depth2, deepest2) = deepest bt2
   ◇ in if depth1 = depth2
      ▪ then (1 + depth1, deepest1 @ deepest2)
      ▪ else if...</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Homework 1" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536586596.32" ts_lastsave="1536931832.86" unique_id="34">
			<rich_text>make simple pocket calculator

numbers interpreted in postfix
• put two numbers on the stack
• when operation pushed to stack, numbers popped
• result pushed back onto stack</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Datatypes and Patterns" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536931832.86" ts_lastsave="1537191105.63" unique_id="37">
			<rich_text>
Can make programs more consice and elegant
• type abbreviations
• ML datatypes
• patterns and local vars


Type Abbreviation
• simple
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• parametric
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ provides a family of abbreviations


ML Datatype Facility
• allows one to create tree-structured data
• abstract and flexible

Simple Sum Types
• datatype suit = Clubs | Diamonds | Hearts | Spades
• datatype card = Club of int | Diamond of int ....
• can also parametrize datatypes
   ◇ datatype ('a, ‘b) pair_or_single = Pair of ’a * ‘b | Single of ’a

Recursive Types
• datatype int_tree = Leaf of int | Node of int * int_tree * int_tree
   ◇ binary tree
   ◇ Node (5, Node(5, Leaf 4, Leaf 7), Leaf 3);

general form
• datatype (&lt;type parameters&gt;) &lt;identifier&gt; = &lt;first constructor expression&gt; | &lt;second&gt; | ...
• list is the quintessential datatype
   ◇ datatype ‘a list = nil | :: of ’a * 'a list

case patterns
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• can be written better as
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ wildcard _ (underscore) matches anything
   ◇ patterns can be nested</rich_text>
			<codebox char_offset="140" frame_height="30" frame_width="395" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">type &lt;identifier&gt; = &lt;type expression&gt;;</codebox>
			<codebox char_offset="160" frame_height="30" frame_width="395" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">type (&lt;type parameters) &lt;identifier&gt; = &lt;type expression&gt;;</codebox>
			<codebox char_offset="884" frame_height="135" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun many_tests x =
    if x = nil
    then 0
    else if tl(x) = nil
        then 1
        else if hd(x) = 3 andalso tl(x) = [2]
            then 6
            else 12;</codebox>
			<codebox char_offset="918" frame_height="105" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun many_tests x =
    case x of
        nil =&gt; 0 |
        (_ :: nil) =&gt; 1 |
        (3 :: (2 :: nil)) =&gt; 6 |
        _ =&gt; 12;</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Trees" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1537191105.64" ts_lastsave="1537536712.05" unique_id="38">
			<rich_text>
Datatype for Binary Trees
• possible definition
   ◇ datatype bi_tree = Leaf of int | Node of bi_tree * bi_tree;
• Leaf is a data point
• node is a junction between two binary trees
• recall our guiding principle
   ◇ recursive function follows the structure of inductively-defined data
   ◇ binary tree functions need two clauses
      ▪ one for leaves
      ▪ one for nodes

Sum of Tree Data
• Sample tree
   ◇ val t = Node(Node(Leaf(3),Leaf(4)),Leaf(1));
• writing tree sum function
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ recursive calls until you reach leaves

Flipping a tree
• same principle
• create new node swapping bt1 and bt2

Tree fringe
• get the leaves at the edges of the tree
• Ex returns [3,4,1]
• leaves return value as a one-item list
• nodes recursively append


General Trees
• arbitrary branching (unknown number of children)
   ◇ no interior values
• datatype ‘a gtree = Leaf of ’a | Node of 'a branches
• datatype ‘a branches = Empty | Branch of ’a gtree * 'a branches;
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ cannot otherwise use mutual recursion for definitions
   ◇ recursion template involves mutual recursion now</rich_text>
			<codebox char_offset="492" frame_height="60" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun tree_sum (Leaf n) = n)
|   tree_sum (Node(bt1, bt2))
        = tree_sum(bt1) + tree_sum(bt2);</codebox>
			<codebox char_offset="970" frame_height="105" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">datatype 'a gtree =
    Leaf of 'a
|   Node of 'a branches
and 'a branches =
    Empty
|   Branch of ‘a gtree * ’a branches;</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Tail Recursion" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1537536712.05" ts_lastsave="1537538160.32" unique_id="41">
			<rich_text>
Converting SumList to Tail Recursion
• standard two-case function
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• recursive calls are unfolded until we reach the end of the list
   ◇ not tail-recursive
• tail recursion has an “actualating parameter”
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ runs 3-4x faster than the previous version


MultList
• very similar to sum_list
   ◇ multiply instead of add
• check if x = 0 then return 0


Fibonacci
• use *two* accumulating parameters
• still need to set first two values manually


Summary
• tail-recursive functions have no computation after recursive call
• good SML compiler detects tail-recursive functions and implements them properly
   ◇ uses loops
   ◇ no stack bindings or return addresses</rich_text>
			<codebox char_offset="72" frame_height="48" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun sum_list nil = 0
|   sum_list (x::xs) = x + sum_list xs</codebox>
			<codebox char_offset="217" frame_height="48" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun f acc [] = acc
|   f acc (x::xs) = f (x+acc) xs</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Exceptions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1537538179.86" ts_lastsave="1538400978.13" unique_id="42">
			<rich_text>
Overview
• used for functions that are not always well-defined

Giving Change
• Problem: given a set of coins (infinite supply of each denomination) produce
   ◇ exact change for given amount
   ◇ use minimal coins
• may not always be possible
   ◇ eg. return 7c using 5c and 3c coins
   ◇ always possible if we have 1c coins
• don't want to test all combos
• greedy strategy
   ◇ return as many from highest denom, then second-highest, etc.
   ◇ not always optimal
      ▪ eg return 8c using 5c, 4c, 1c
      ▪ optimal for US coin set</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Program Stages" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538400978.13" ts_lastsave="1539005469.99" unique_id="45">
			<rich_text>
Ambiguity, Solution
• rewrite grammar to enforce precedence and associativity

Abstract Syntax
• once structure of tree is correct, forget irrelevant details
• abstract syntax tree for an expression is of the form
   ◇ NumT(z) with z an int, or
   ◇ TimesExp together with two expressions, or
   ◇ PlusExp w/ two expressions, or
   ◇ Minus Exp together w/ two expressions


Convert to Abstract Syntax</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Lazy Evaluation" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1539005469.99" ts_lastsave="1539351055.07" unique_id="47">
			<rich_text>
Can we represent infinite lists?
• eg. set of all natural numbers
   ◇ can try fun all_numbers n = n :: (all _numbers (n + 1))
   ◇ has type int -&gt; int list
   ◇ but `all numbers 1` does not terminate and produces no result


Lazy Eval
• Key Idea
   ◇ evaluate lists one element at a time
   ◇ generate element only when needed
   ◇ list tail is thus not fully evaluated yet
   ◇ new attempt:
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ not quite type correct


Lazy Lists
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• then define hd, tl with types
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ and raise new exceptions:
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• can now define sequence containing all numbers</rich_text>
			<codebox char_offset="399" frame_height="48" frame_width="260" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fun all_numbers n =
    n :: (fn () =&gt; all_numbers (n+1))</codebox>
			<codebox char_offset="444" frame_height="60" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">datatype 'a lseq =
    Nil
    | Cons of ‘a * (unit -&gt; ’a lseq)</codebox>
			<codebox char_offset="483" frame_height="30" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">hd: ‘a lseq -&gt; ’a tl: ‘a lseq -&gt; ’a lseq</codebox>
			<codebox char_offset="521" frame_height="95" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">exception Empty
fun hd Nil = raise Empty
|   hd (Cons (x,_)) = x
fun tl Nil = raise Empty
|   tl (Cons (_,sf)) = sf ()</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Implementing First-Order Functions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1539351055.07" ts_lastsave="1539955800.45" unique_id="50">
			<rich_text>
Motivation
• goal: learn how to implement a functional language
   ◇ includes higher-order features
   ◇ will work stepwise
      ▪ as in the Krishnamurthi textbook
• first-order functions
   ◇ cannot take other functions as input
   ◇ cannot return functions as a result
• for simplicity, assume
   ◇ function takes one integer argument
   ◇ function returns one integer


Syntax (top-level)
• processing
   ◇ interpreter needs to modify
      ▪ lexical analysis
      ▪ parser
      ▪ abstract syntax
• evaluation (abstract)
   ◇ numbers handled as before
   ◇ operators (+,-,*) handled as before
      ▪ recursive calls on operands
      ▪ apply operator to results
   ◇ function calls
      ▪ for a call f(e</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>) we need to look up the definition of f x = e</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>
      ▪ then take action based on
         - e0, the body of f
         - x, the formal parameter of f
         - e1, the actual parameter of f
      ▪ two approaches
         - substitutions
         - environments


Substituion approach
• for a call f(e</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>) with body f x = e</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>, then
   ◇ substitute in the body e</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>
      ▪ for each occurrence of the formal parameter x
      ▪ replace it with the actual parameter e</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>
   ◇ evaluate the resulting expression
• when to evaluate actual parameters?
   ◇ should we eval actual parameter before substituting it for the formal
      ▪ we may -&gt; Call by Value
      ▪ may not -&gt; Call by Name
   ◇ example: g x = x + x; g(g(4));


Environment approach
• new strategy
   ◇ defer substituitions by means of an environment
• environment is a dictionary that keeps track of what identifiers are bound to
   ◇ numbers?


Closure
• def:
   ◇ function definition
   ◇ along with environment
• created when interpreting a function definition
• interpreting top-level function def is a special case
• closures are </rich_text>
			<rich_text style="italic">applied</rich_text>
			<rich_text> when interpreting a function call
   ◇ if the function part evaluates to a closure (x, b, env)
   ◇ now evaluate b in environment that
      ▪ extends env
      ▪ binds x</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Racket Language" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1539955800.46" ts_lastsave="1541165458.19" unique_id="51">
			<rich_text>
Motivation
• used at Northeastern University
• Reasoning:
   ◇ simple gramar
   ◇ comes with several libraries
   ◇ multi-paradigm language
      ▪ not restricted to a specific programming style
   ◇ untyped language</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Mutations" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1541165458.2" ts_lastsave="1541166136.6" unique_id="53">
			<rich_text>
Combining Paradigms
• know how to interpret imperative languages
   ◇ bindings may change with time
   ◇ functions are not first-class citizens
• know how to interpret functional languages
   ◇ functions are first-class
   ◇ bindings do not change
• how to interpret language that combines both paradigms
   ◇ functions are first-class
   ◇ bindings can change
• will proceed by extending the interpreter for higher-order functions
   ◇ interpreter using environments and closures
   ◇ this will allow bindings to change


Boxes, Spec
• what is changed can either be
   ◇ a field in an object
   ◇ an identifier
      ▪ called a variable
• to model the former, introduce boxes
   ◇ a box is an abstract of an object
   ◇ only one field
• 3 box operations
   ◇ creation  initialization, by `box`
   ◇ getting content, by `unbox`
   ◇ setting content, by `set-box!`


Sequencing
• extend higher-order functional language further
   ◇ now time matters
   ◇ sequencing makes sense
• let v = e1 in e2 means:
   1) interpret e1
   2) bind resulting value to v and interpret e2
• lazy evaluation doesn't mix with call-by-name
• sequencing: e1 ; e2 is similar
   ◇ e1 is not interpreted for its value
   ◇ interpreted for its side effect</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="True" name="CIS 560" prog_lang="plain-text" readonly="False" tags="" ts_creation="1534955805.15" ts_lastsave="1535732771.78" unique_id="4">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="August 22, 2018" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1534955834.62" ts_lastsave="1535127949.13" unique_id="5">
			<rich_text>What is a database?
• place where you store data
• used everywhere
   ◇ online courses
   ◇ KSIS
   ◇ Banking and retail systems'

Benefits of databases
• centralized
• persistent
   ◇ data isn't just stored in memory
   ◇ information can survive a system failure
• key functions
   ◇ control changes to data
      ▪ need a known state
      ▪ two users can change the same piece of data near-simultaneously
      ▪ if system crashes, data can be found in previously known state
   ◇ retrieve data
      ▪ as quickly as possible

Makeshift DB - Excel
• Problems
   ◇ no data typing
   ◇ no built-in sorting
   ◇ inconsistent formatting

Operations
• just as in mathematics:
   ◇ ops on nums give new nums
      ▪ most take in two nums and provide a new one
   ◇ ops on datasets give new datasets
• basic operations
   ◇ selection
      ▪ extract subset of rows
   ◇ projection
      ▪ extract subset of columns
   ◇ join
      ▪ combine information from two datasets

Relational Theory terms
• relation
   ◇ two-dimensional table with rows and columns
• attributes
   ◇ columns of the relation
   ◇ attributes are a set, not a list
      ▪ each item must be unique
      ▪ no order
• tuples
   ◇ rows of the relation
   ◇ tuples are a set, not a list
      ▪ uniqueness must be enforced by the user
• domain
   ◇ elementary type for each attribute
   ◇ value must not be set, list, array etc
• keys
   ◇ set of attributes that prevent two tuples in a relation from having the same values in all key attributes
• schema
   ◇ complete database design
</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="DB History" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1534956191.0" ts_lastsave="1534956300.12" unique_id="6">
				<rich_text>
Life pre-databases
• flat file interaction led to 
   ◇ tedious code
   ◇ repeated code
   ◇ direct file access
      ▪ slow and insecure

Early databases
• early databases were fairly static
   ◇ information stored in flat files
   ◇ very difficult to add new capabilities
   ◇ programs had to know DB structure to navigate it

Edgar Codd
• IBM Researcher
• around '70 realized databases can be built on mathematical foundations
• work turned into relational theory of databases
   ◇ set theory
   ◇ predicate logic</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Key Concepts" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535127949.13" ts_lastsave="1535387528.44" unique_id="12">
			<rich_text>
• Avoid Duplicates
   ◇ each item should be uniquely identifiable
• Standardize
   ◇ store once
• Split tables
• store one piece of data per column

Adding Information
• new fields = new columns
• item fits in multiple categories under one label?
   ◇ eg. music album under several genres
   ◇ add album identifier (unique key)
   ◇ add genre table using unique foreign key
• more detailed information
   ◇ eg. songs in an album
   ◇ add extra table for individual songs w/ foreign key
   ◇ add table mapping album keys to song keys

Entity Sets
• each item is an entity
• can organize into sets and relate them to each other
• eg:
   ◇ albums(</rich_text>
			<rich_text underline="single">album_id</rich_text>
			<rich_text>, title, released)
   ◇ artists(</rich_text>
			<rich_text underline="single">artist_id</rich_text>
			<rich_text>, name)
   ◇ countries(continent, name, </rich_text>
			<rich_text underline="single">code</rich_text>
			<rich_text>)
• relationships show how tables connect
• E/R Diagram shows relationships

Cardinality
• 1 -&gt; many relationship
   ◇ noted as (1,n)
   ◇ eg. one album to many songs
• 0 -&gt; many
   ◇ (0, n)
   ◇ songs that are covers of other songs
• many -&gt; many
   ◇ (m, n)
   ◇ multiple albums to multiple genres

Normalization
• 1st normal form
   ◇ simple attributes
   ◇ single value per field
   ◇ values have simple types
• 2nd normal form
   ◇ adheres to 1st normal form
   ◇ attributes attend on full key
• 3rd normal form
   ◇ adheres to 2nd normal form
   ◇ non-key attributes do not depend on each other
   ◇ every non-key attribute must provide a fact about the key, the whole key, and nothing but the key - William Kent

What makes an artist?
• bands vs solo artists
   ◇ solo artists can be part of a band
• make 3 tables
   ◇ artists(key ID, string Name, char type)
   ◇ bands(key ID, string origin_city, string origin_country)
   ◇ individuals(key ID, string Firstname, date born, date died)</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="album table 1" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535130307.46" ts_lastsave="1535130949.21" unique_id="13">
				<rich_text justification="left"></rich_text>
				<rich_text>

Want to add a genre field, but multiple genres per album

</rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text>

BAD practice
• multiple items in the genre field

Better practice
• add second table for genre
• add new field to albums for album ID

</rich_text>
				<rich_text justification="left"></rich_text>
				<table char_offset="0" col_max="60" col_min="40">
					<row>
						<cell>Thriller</cell>
						<cell>1</cell>
						<cell>1982</cell>
					</row>
					<row>
						<cell>Led Zeppelin IV</cell>
						<cell>2</cell>
						<cell>1971</cell>
					</row>
					<row>
						<cell>Recovery</cell>
						<cell>3</cell>
						<cell>2010</cell>
					</row>
					<row>
						<cell>...</cell>
						<cell>...</cell>
						<cell>...</cell>
					</row>
					<row>
						<cell>Album</cell>
						<cell>Artist ID</cell>
						<cell>Released</cell>
					</row>
				</table>
				<table char_offset="61" col_max="90" col_min="40">
					<row>
						<cell>Thriller</cell>
						<cell>1</cell>
						<cell>1982</cell>
						<cell>Pop, Rock, R&amp;B</cell>
					</row>
					<row>
						<cell>Led Zeppelin IV</cell>
						<cell>2</cell>
						<cell>1971</cell>
						<cell>Hard Rock, Heavy Metal</cell>
					</row>
					<row>
						<cell>Album</cell>
						<cell>Artist ID</cell>
						<cell>Released</cell>
						<cell>Genre</cell>
					</row>
				</table>
				<table char_offset="199" col_max="90" col_min="40">
					<row>
						<cell>1</cell>
						<cell>Thriller</cell>
						<cell>1</cell>
						<cell>1982</cell>
					</row>
					<row>
						<cell>2</cell>
						<cell>Led Zeppelin IV</cell>
						<cell>1971</cell>
						<cell>1971</cell>
					</row>
					<row>
						<cell>Album ID</cell>
						<cell>Album</cell>
						<cell>Artist ID</cell>
						<cell>Released</cell>
					</row>
				</table>
				<table char_offset="200" col_max="90" col_min="40">
					<row>
						<cell>1</cell>
						<cell>pop</cell>
					</row>
					<row>
						<cell>1</cell>
						<cell>rock</cell>
					</row>
					<row>
						<cell>1</cell>
						<cell>r&amp;b</cell>
					</row>
					<row>
						<cell>Album ID</cell>
						<cell>Genre</cell>
					</row>
				</table>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Null" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535130733.88" ts_lastsave="1535130769.05" unique_id="14">
				<rich_text>
Concept of Nothingness
• not a special value
• don't want to use 0 for empty int field
   ◇ 0 could have value</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Constraints" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535387528.44" ts_lastsave="1535560183.03" unique_id="17">
			<rich_text>
Table Structure
• physical form of a relation
• columns are a set, not a list
   ◇ order doesn't matter
   ◇ unique items
• columns must have
   ◇ unique name
   ◇ data type
   ◇ nullability

Constraints
• declarative rules for one or more columns
• DBMS will check every time
   ◇ new data is added
   ◇ data is modified
   ◇ when data is deleted
      ▪ only in some cases (foreign keys)
• operations that violate a constraint fail and return an error

NOT NULL
• parameter constraint
• prevents addition of NULL values in that column
• indicates field is mandatory

Primary Key
• value is mandatory
• value must be unique

Unique
• Enforces uniqueness like a PRIMARY KEY
• can have more than one UNIQUE constraint
• will allow NULL values

Check Constraints
• Can force domain ranges
   ◇ e.g. 0 to 100
• check for discrete values
   ◇ Yes, No, Maybe
• comparison between two columns
   ◇ endDate &gt;= StartDate
• andy predicate using columns of the table

Foreign Keys
• enforce referential integrity
• rules
   ◇ referenced columns must be either primary key or UNIQUE
   ◇ referencing columns must match type of referenced column
• constraint works both directions
   ◇ referencing table checked when foreign key value is inserted or updated
   ◇ referenced table is checked when value is deleted

Default Constraints
• defines default value of column
• used on inserts when explicit value not provided
• can provide value for column w/ default constraint</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="T-SQL Fundies" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535560183.03" ts_lastsave="1536338015.83" unique_id="22">
			<rich_text>
SQL Schmas and Objects
• almost everything inside a database is an object
• a schema is a container that holds objects
   ◇ similar to a namespace
• schema cannot hold other schema
• full qualified object name includes the schema name
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Query Basics
• SQL is declarative
   ◇ define what you want, not how to get it
• SQL is set-oriented
   ◇ not procedural like OOP languages
   ◇ order rarely matters to accomplish what you want

SELECT
• only element required in a SELECT statement
• Usually have SELECT and FROM
• Column aliasing is supported
   ◇ sometimes required
• provides support for </rich_text>
			<rich_text weight="heavy">projection</rich_text>
			<rich_text> operation

FROM
• defines which table(s)
   ◇ where to get the data
• Table aliasing is supported
• resulting column names in SELECT inherit column names from table

Booleans
• only supported as expressions
   ◇ no boolean data type
   ◇ cannot be stored in variable, column, or result set
• three possible values
   ◇ TRUE, FALSE, and UNKNOWN

GROUP BY Element
• defines distinct set by one or more columns or expressions
• Aggregates
   ◇ almost all aggregate functions have this syntax:
      ▪ &lt;Function Name&gt; ( [ </rich_text>
			<rich_text underline="single">ALL</rich_text>
			<rich_text> | DISTINCT ] expression )
   ◇ examples are MIN, MAX, AVG, and SUM
   ◇ COUNT and COUNT_BIG are similar but allow for no expression (*)
   ◇ can be used with the OVER clause to define partitions
   ◇ NULL values are ignored</rich_text>
			<codebox char_offset="241" frame_height="20" frame_width="205" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">SELECT * FROM Sales.Orders;</codebox>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Single-Table Queries" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535734058.02" ts_lastsave="1536165269.14" unique_id="27">
				<rich_text>
HAVING
• provides post-grouping filter
• like WHERE, accepts any boolean element

ORDER BY
• order set by specific element
• provides ability to sort rows of the result set
   ◇ useful for presentation
   ◇ useful for data processing or loading algorithms
• ascending and descending orders are supported
   ◇ optional ASC and DESC keywords
   ◇ ASC is default behavior
      ▪ do not assume behavior

SELECT Statement Processing Order
• Major elements of select
• ANSI Order
   ◇ SELECT
   ◇ FROM
   ◇ WHERE
   ◇ GROUP BY
   ◇ HAVING
   ◇ ORDER BY

SELECT DISTINCT
• Guarantees uniqueness in result
• all columns of the result are evaluated to remove duplicates
• like with aggregates, ALL is the default if DISTINCT not specified
• the result is a true set with unique tuples
• if using with ORDER BY, the ORDER criteria must be in the select list

TOP filter
• Filter rows based on ordering
• accepts a numeric expression
   ◇ TOP (expression) [PERCENT] [ WITH TIES ]
   ◇ PERCENT - expression defines the TOP N% of rows to return
   ◇ WITH TIES: Allows additional rows withthe same value as the last row
• TOP is non-standard

OFFSET-FETCH Filter
• Like TOP, filters based on ordering
• Unlike TOP
   ◇ standard SQL
   ◇ supports an offset
• Syntax
   ◇ OFFSET &lt;int. expr&gt; { ROW | ROWS } [ FETCH { FIRST | NEXT } &lt;int. expr&gt; {ROW | ROWS} ONLY ]
• gives options for readability
   ◇ 1 ROW vs 2 ROWS
   ◇ FETCH FIRST 100 vs FETCH NEXT 100


ANSI Processing Order (Logical)
• FROM
• WHERE
• GROUP BY
• HAVING
• SELECT
• DISTINCT
• ORDER BY
   ◇ OFFSET ... FETCH is part of ORDER BY
• TOP
   ◇ nonstandard</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Predicates" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536165269.14" ts_lastsave="1536167831.95" unique_id="29">
				<rich_text>
IN
• checks whether value is equal to at least one element in the provided set

BETWEEN
• checks if value is within specified range
• boundary values are inclusive

LIKE
• evaluates whether character string meets a specific pattern
• ‘%’ is the wildcard
• can be paired with NOT

Operator precedence
1. ()
2. *,/,%
3. +,-
4. =,&gt;,&lt;.&gt;=,&lt;=,&lt;&gt;
5. NOT
6. AND
7. BETWEEN, IN, LIKE, OR
8. = (Assignment)

CASE Expression
• Simple Form
   ◇ compares scalar values and returns value with first match
• Searched Form
   ◇ evaluates predicates looking for first match
   ◇ first match defined by TRUE expression
• Other useful functions
   ◇ ISNULL
      ▪ first null argument
   ◇ COALESCE
      ▪ first non-null argument
      ▪ only standard function
   ◇ IIF
   ◇ CHOOSE


Variables
• use DECLARE statement
• initializer is optional
   ◇ NULL by default
• syntax
   ◇ must always be previxed with ‘@’
   ◇ DECLARE @VarName INT = 0;
• multiple variables can be declared in single statement
   ◇ </rich_text>
				<rich_text justification="left"></rich_text>
				<rich_text>


Converting Data Types
• CAST
   ◇ Standard SQL
   ◇ Similar to other languages
   ◇ Syntax
      ▪ SELECT CAST(@IntValue AS VARCHAR(10))
• CONVERT
   ◇ optional formatting
   ◇ Syntax
      ▪ SELECT CONVERT(VARCHAR(10), @IntValue)

Character Data Types
• Fixed-length types
   ◇ CHAR
      ▪ declaration: CHAR [ (n) ]
   ◇ NCHAR
      ▪ declaration: NCHAR [ (n) ]


Character Data Types: String Functions
• ASCII &amp; CHAR
• CHARINDEX, SUBSTRING, LEFT, RIGHT
• UPPER &amp; LOWER
• LTRIM &amp; RTRIM
• REPLACE, REPLICATE, STUFF</rich_text>
				<codebox char_offset="988" frame_height="60" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">DECLARE
    @Var1 INT
    @Var2 CHAR;</codebox>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Data" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536338015.83" ts_lastsave="1536338942.03" unique_id="32">
			<rich_text>
Date/Time Datatypes
• old data types: DATETIME and SMALLDATETIME
• not used in SQL 2008+
• do not align with the SQL standard
• new types
   ◇ DATE
   ◇ TIME
   ◇ DATETIME2
      ▪ combines date and time
   ◇ DATETIMEOFFSET
      ▪ adds 2-byte timezone offset to DATETIME2
• Functions
   ◇ SYSDATETIME()
   ◇ SYSDATETIMEOFFSET()
   ◇ SYSUTCDATETIME()
   ◇ DATEDIFF()
      ▪ can specify which unit (days, months, years) to compare</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Joins" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536338942.03" ts_lastsave="1536769937.84" unique_id="33">
			<rich_text>
Joins
• operate on two separate tables
• produce one output table
• three types
   ◇ CROSS JOIN
   ◇ INNER JOIN
   ◇ OUTER JOIN


Cross Join
• single processing phase
   ◇ produces cartesian product
• two supported syntaxes
   ◇ ANSI SQL-89
   ◇ ANSI SQL-92


Inner Join
• Two logical processing phases
   ◇ produces cartesian product
   ◇ filters rows based on provided predicate
• two supported syntaxes
   ◇ ANSI SQL-89
   ◇ ANSI SQL-92


Outer Join
• Three logical processing phases
   ◇ cartesian product
   ◇ filters rows based on predicate
   ◇ adds rows from preserved table
• preserved table is identified by key word
   ◇ LEFT - the left table is preserved
   ◇ RIGHT - the right table is preserved
   ◇ FULL - both tables preserved
• only one syntax supported
   ◇ ANSI SQL-92


Table Operators - Review
• used in FROM element
• perform operations on input tables and produce output table
• JOIN is only standard operator</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Subqueries" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536769937.84" ts_lastsave="1537202122.39" unique_id="36">
			<rich_text>
Joins Review
• Operate on two input tables
• produce single output table
• three types
   ◇ cross
   ◇ inner
   ◇ outer


Subqueries
• queries within queries
   ◇ nested queries
• terms
   ◇ outer query
      ▪ query whos result set is returned to the caller
   ◇ inner query or subquery
      ▪ query wose result set is returned to the outer query
• Variations
   ◇ self-contained
      ▪ no dependence on outer query
   ◇ correlated
      ▪ depends on outer query
• types of returns
   ◇ single-valued: scalar value only
   ◇ multi-valued: single column, zero or more rows
   ◇ table-valued: one or more columns, zero or more rows


Self-contained Scalar Subqueries
• returns a single value
• can appear anywhere in the outer query where single-valued expression is allowed
• if single value isn't returned
   ◇ if no value, null is returned
   ◇ if multiple values, query fails


Self-contained Multi-value subqueries
• returns multiple values as a single column
• can be used with the predicate IN
• Syntax: &lt;scalar_expr&gt; IN (&lt;multi-valued subquery&gt;)
• can often be rewritten with JOINs</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Table Expressions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1537202122.4" ts_lastsave="1538411820.38" unique_id="40">
			<rich_text>
Overview
• subset of subqueries
• named query expressions that represent a valid table
• not materialized
   ◇ virtual
   ◇ references to table expression are internally translated to a query
• benefits are logical aspects of code
   ◇ code structure and readability
   ◇ possible code re-use

Derived Tables
• aka table-valued subqueries
   ◇ self-contained subqueries
• defined in the FROM clause of the outer query
   ◇ scope of existence is the outer query
   ◇ as soon as outer query is finished, derived table is gone
• two forms of column aliasing: inline vs external
• nesting is supported


Commont Table Expressions (CTEs)
• similar to derived tables
• scope is outer query
• also supported
   ◇ both forms of column aliasing
   ◇ multiple CTEs
   ◇ Multiple references to single CTE
   ◇ recursive CTEs


Views and Inline TVFs
• derived tables and CTEs have single-statement scope
• views and inline table-valued functions (TVFs) have broader scope
   ◇ stored as db objects
   ◇ available until explicitly dropped
• can be thought of as a parameterized view


APPLY Operator
• Nonstandard table operator
   ◇ standard defines LATERAL joins


Window Functions
• for each row, computes scalar value based ona calculation against a subset of the rows
   ◇ subset known as the window
• similar results as GROUP BY
   ◇ preserves detail from all rows
• uses OVER clause, containing three parts
   ◇ partitioning
   ◇ ordering
   ◇ framing
• categories
   ◇ Ranking window functions
   ◇ analytic window functions
      ▪ includes offset functions
   ◇ aggregate window functions</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Window Functions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1537807000.83" ts_lastsave="1537808161.35" unique_id="43">
				<rich_text>
Aggregate Window Functions
• typical aggregat functions supported
   ◇ count, sum, min, max, avg
   ◇ distinct is </rich_text>
				<rich_text weight="heavy">not</rich_text>
				<rich_text> </rich_text>
				<rich_text weight="heavy">supported</rich_text>
				<rich_text>
• over clause usage
   ◇ partitioning, ordering, framing all supported
• common uses w/ framing
   ◇ running totals
   ◇ period running totals (MTD, YTD)
   ◇ moving averages</rich_text>
			</node>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Multisets" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1537808161.36" ts_lastsave="1537809362.49" unique_id="44">
				<rich_text>
Multiset properties
• allows duplicates
• non-sorted


Union - A ∪ B
• union of two sets is the set containing all members from A and B
• UNION ALL - Multiset Operator
• UNION - distinct set operator


INTERSECT - A ∩ B
• intersection of two sets is set containing only members in both A and B
• INTERSECT - distinct set
• INTERSECT ALL - Multiset
   ◇ not supported in T-SQL
   ◇ possible to work around the limitation


EXCEPT: A - B
• set of elements in A and not in B
• equal to (A ∪ B) - B
• EXCEPT ALL - multiset
   ◇ not supported in T-SQL
   ◇ possible to work around


Precendence
1. Intersect
2. Union, Except
• can use parenthesis to ocntrol evaluation order</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Data Modification" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1538411820.38" ts_lastsave="1540560577.06" unique_id="46">
			<rich_text>
Inserting
• several ways to insert data
• three methods
   ◇ INSERT ... VALUES ...
   ◇ INSERT ... SELECT ...
   ◇ INSERT ... EXEC ...


INSERT
• syntax:
   ◇ INSERT [INTO] Table(&lt;column list&gt;)
      ▪ into is optional
      ▪ column list is optional, but should be included
• if a column in the table is omitted
   ◇ if default constraint, default value is assigned
   ◇ else if it allows nulls, then NULL is inserted
   ◇ otherwise the insert fails


Inserting Data
• sometimes need value from identity column
   ◇ might want to present results
• identity functions
   ◇ @@IDENTITY
      ▪ returns last identity value generated in the session
   ◇ SCOPE_IDENTITY()
      ▪ returns last identity value generated by the current scope
• IDENTITY
   ◇ non-standard, but simple
   ◇ standard SQL defines a SEQUENCE object


Deleting Data
• two ways to delete
   ◇ DELETE
      ▪ supports FROM clause, non-standard
   ◇ TRUNCATE
      ▪ deletes ALL rows
      ▪ minimally logged =&gt; fast
      ▪ resets the IDENTITY value
      ▪ can have no foreign keys referencing the table</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Design Principles &amp; Practice" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1539016167.69" ts_lastsave="1541003704.66" unique_id="48">
			<rich_text>
Good Design
• taken for granted so far


Design Principles
• avoid unnecessary complexity
• avoid repetition


Why?
• data integrity
   ◇ maintains accuracy and consistency
   ◇ data is recorded and retrieved as intended
   ◇ helps avoid unintentional changes
• easier maintenance of data
• easier maintenance of code</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Obtaining Good Design" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1539189364.44" ts_lastsave="1539190416.31" unique_id="49">
				<rich_text>
Achieving good design
• database researchers developed normal forms


Functional dependencies
• form of constraint
• finding them is part of DB design
• defined
   ◇ if two tuples agree on attributes A</rich_text>
				<rich_text scale="sub">1</rich_text>
				<rich_text>, A</rich_text>
				<rich_text scale="sub">2</rich_text>
				<rich_text>, ..., A</rich_text>
				<rich_text scale="sub">n</rich_text>
				<rich_text>


Anomalies
• occur when bad FDs hold
• Know some FDs
   ◇ need to find all FDs</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Transactions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1541003704.67" ts_lastsave="1542044259.75" unique_id="52">
			<rich_text>
ACID Properties
• Atomicity
   ◇ all or nothing
• consistency
   ◇ ensures one valid state to another
• isolation
   ◇ concurrent transactions are independent
• Durability
   ◇ fault-tolerance


Locks
• similar to system locks
• used to control access by a process
• modes
   ◇ exclusive - required for modifications
      ▪ held until transaction completes
   ◇ shared - read lock preventing modifications but allows concurrent reading


Blocking
• occurs when too many locks in place
• shared lock allows access to other transactions requesting shared locks
   ◇ blocks transactions asking for exclusive lock
• exclusive lock blocks all other transactions


consistency
• dirty reads
   ◇ reading data not yet committed
• non-repeatable reads
   ◇ reading same row twice w/ different results
• phantom rows
   ◇ read a set of rows twice, get different set each time


Isolation Levels
• Read Uncommitted
   ◇ no data consistency
   ◇ allows dirty reads
• Read Committed
   ◇ prevents dirty reads
   ◇ default behavior
• repeatable read
   ◇ prevents dirty and non-repeatable reads
• serializable
   ◇ prevents all


Snapshot Isolation Level
• similar to PostGRES
• features
   ◇ same level of consistency as serializable
   ◇ writers don't block readers
   ◇ readers don't block writers
• how does it work?
   ◇ uses row versioning rather than shared locks
   ◇ readers get version of data that existed at start of transaction
      ▪ prevents reading data that changed mid-transaction
   ◇ more overhead
      ▪ row versions tracked in tempdb


</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Data Warehouses" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1542044259.76" ts_lastsave="1542044662.63" unique_id="54">
			<rich_text>
What are Data Warehouses?
• relational databases specialized for reporting
• copy data from source system(s) into specialized structure
• other terms:
   ◇ Decision Support System (DSS)
   ◇ Online Analytical Processing (OLAP)
      ▪ vs Online Transactional Processing (OLTP)


Why?
• offloads expensive queries from prod system
• transform data into structure designed for reporting
• calculations and business metrics are designed and implemented once
• simpler ad-hoc reports
• first step to Business Intelligence solution


Business Intelligence
• Data -&gt; Information -&gt; Knowledge</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="True" name="STAT 510" prog_lang="plain-text" readonly="False" tags="" ts_creation="1535034756.68" ts_lastsave="1535034756.68" unique_id="7">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="August 21, 2018" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535035476.4" ts_lastsave="1535035508.66" unique_id="9">
			<rich_text>
Terminology
* Sample Space - all possible results from an activity
 * Denoted by S
 * Discrete S: finite or countable outcomes
 * subset of S is an event
* Random Experiment - activity that can result in different outcomes despite identical repetitions

Combining Events
* complement of event A
* union
* intersection

Mutually Exclusive Events
* events w/ no elements in common
* intersection is {}
* cannot occur as a result of the same repetition of the experiment

Probability
* notation: P(A)
* can assign probability to event A
* Axioms
 * for any event E: 0 &lt;= P(E) &lt;= 1
 * for sample space S: P(S) = 1
 * if events A and B are mutex: P(A U B) = P(A) + P(B)
* Implication
 * P(A`) = 1 - P(A)
 * P({}) = 0

General Addition Rule:
* for any two events A and B
 * P(A U B) = P(A) + P(B) - P(A ∩ B)
</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="August 23, 2018" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535035508.66" ts_lastsave="1535467721.5" unique_id="8">
			<rich_text>
Conditional Probability
• Know part of what will happen
• need to know the rest of the system

Example </rich_text>
			<rich_text link="file L2hvbWUvc3NjaG1hbHovQ2xhc3Nlcy9TVEFUNTEwL1NUQVQgNTEwIC0gQ2hhcHRlciAyLnBkZg==">(slide 15)</rich_text>
			<rich_text>
• known: waver has high contamination (H)
• find: probability of center -&gt; P(C)
   ◇ need to fix slide 15, swap H and C
• noted as P( C | H )
   ◇ </rich_text>
			<rich_text background="#ffffffff0000">conditional probability of C given H</rich_text>
			<rich_text>

Calculation
• P(A | B) = P(A ∩ B) / P(B)
• in reverse:
   ◇ P(A ∩ B) = P(A | B) * P(B)
   ◇ called Bayes Theorem

General Usage
• have number </rich_text>
			<rich_text style="italic">k</rich_text>
			<rich_text> of distinct events {E</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>, E</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text>, ..., E</rich_text>
			<rich_text scale="sub">k</rich_text>
			<rich_text>}
• event A is a separate event
• P(A) is separate from P(E)
• P(A) = P(A ∩ E1) + P(A ∩ E2) + ... + P(A ∩ Ek)
   ◇ </rich_text>
			<rich_text background="#ffffffff0000">Rule of Total Probability</rich_text>
			<rich_text>
   ◇ often combined with Bayes Theorem</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Tree Diagrams" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535038762.49" ts_lastsave="1535039003.43" unique_id="10">
				<rich_text>
Similar to a flowchart

Wafer Example:
• H = high contamination
   ◇ P(H) = 0.381
• C = center
   ◇ P© = 0.666
• P(C | H) = 0.312
• P(H | C) = 0.179

Can build branching tree to show probabilities</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="August 28, 2018" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535467721.5" ts_lastsave="1535639607.02" unique_id="18">
			<rich_text>
Definition
• Independent
   ◇ two events A &amp; B are independent if P(A | B) = P(A)
      ▪ or P(B | A) = P(B)
      ▪ or P(A ∩ B) = P(A)P(B)

Example
• suppose we have K events E1, E2, ..., Ek
• suppose events are
   ◇ mutually exclusive
   ◇ collectively exhaustive
• exactly one event must occur
• suppose we have another event B, separate from E1, E2, ... Ek
• Rule of Total Probability
   ◇ P(B) = P(B | E1)*P(E1) + P(B | E2)*P(E2) + ... + P(B | Ek)*P(Ek)

Reversing direction of the condition
• formula
   ◇ known: P(A | B) = P(A ∩ B) / P(A)
      ▪ provides: P(A ∩ B) = P(A | B) * P(B)
   ◇ known: P(B | A) = P(B ∩ A) / P(A)
      ▪ provides P(B ∩ A) = P(B | A) * P(A)
   ◇ result: P(A | B) * P(B) = P(B | A) * P(A)
      ▪ provides P(A | B) = (P(B | A) * P(A)) / P(B)
• Known as Bayes' theorem

Example: Total Probability
• parts come from 3 suppliers
   ◇ supplier A
      ▪ 5% defective
      ▪ delivers 15% of all parts
   ◇ supplier B
      ▪ 3% from B are defective
      ▪ delivers 25% of all parts
   ◇ supplier C
      ▪ 1% from C are defective
      ▪ delivers 60% of all parts
• what is probability part is defective? (denoted as event D)
   ◇ P(D) = P(D|A)*P(A) + P(D|B)*P(B) + P(D|C)*P(C) = 0.05*0.15 + 0.03*0.25 + 0.01*0.60 = 0.021
   ◇ 2.1% chance of defective part
• given a part, if it is defective what is the probability it came from supplier A?
   ◇ P(A | D) = (P(D | A) * P(A)) / P(D) = (0.05 * 0.15)/0.21 = .357
</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Drug Test Example" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535470111.04" ts_lastsave="1535470502.54" unique_id="19">
				<rich_text>

Baye's Example: Random Drug Testing
• 36% of U.S. teenagers use marijuana
• apply drug test to random U.S. teenager
   ◇ test can be positive (P)
   ◇ test can be negative (P`)
• results of test
   ◇ correct
      ▪ teenager is user and P
      ▪ teenager is not user and P`
   ◇ incorrect
      ▪ teenager is not user and P - false positive
      ▪ teenager is user and P` - false negative
• let event M be the event that the teen uses marijuana

Probabilities
• P(P | M`) = 0.10
• P(P` | M) = 0.15
• P(M`) = 0.64
• P(M) = 0.36

Teenager takes drug test and it is P
• what is probability of M?
• P(M | P) = (P(P | M) * P(M))/P(P) = (1 - 0.15)*0.36 / (P(P | M)*P(M) + P(P | M`) * P(M`)) = 0.85 * 0.36 / (0.15 * 0.36 + 0.10 * 0.36) = 0.827</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="August 30, 2018" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535639607.02" ts_lastsave="1536071443.71" unique_id="23">
			<rich_text>Chapter 3

• We associate probabilities for discrete random variables either by
   ◇ table of probabilities
   ◇ an equation or formula

Example 3.1 p. 43
• time to recharge battery
   ◇ three items
   ◇ each item either passes or fails
   ◇ for any one item, prob of pass is 0.8
   ◇ items are independent
• random variable X is the number of passes
• possible outcomes
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text> </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
      ▪ second chart is the Probability Mass Function </rich_text>
			<rich_text weight="heavy">(pmf)</rich_text>
			<rich_text>
      ▪ probability that X == x
         - f(x) = P(X = x)
   ◇ for a valid pmf, we must have
      ▪ f(x) &gt;= 0 for all X
      ▪ sum of all f(x) = 1
• Instead of using a pmf, can use a cumulative distribution function </rich_text>
			<rich_text weight="heavy">(cdf)</rich_text>
			<rich_text> to define probabilities
   ◇ use same letter as pmf for random var
   ◇ F(x) = P(X &lt;= x)
      ▪ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Definitions
• Distribution: the distribution of the probabilities for the various values of a rnadom variable
• distribution mean: “average” of all values
   ◇ measure of central location
   ◇ gives us a “typical” value of the random variable
   ◇ AKA the expected value
   ◇ denoted by μ (Greek Letter mu)
   ◇ for our example:
      ▪ μ = 0*0.008 + 1*0.096 + 2*0.384+3*0.512=2.4
      ▪ on average we expect to see 2.4 passes
• Dispersion
   ◇ variance of random variable
   ◇ V(X) or σ</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> (sigma squared)
   ◇ σ</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> = Σ</rich_text>
			<rich_text scale="sub">x</rich_text>
			<rich_text> (x - μ)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> * f(x)
      ▪ for hand calculations, use σ</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> = {Σ</rich_text>
			<rich_text scale="sub">x</rich_text>
			<rich_text> x</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> * f(x)} - μ</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>
   ◇ standard deviation = √(variance) = σ
      ▪ for our example, σ = √(0.48) = 0.6928</rich_text>
			<table char_offset="376" col_max="120" col_min="40">
				<row>
					<cell>pass</cell>
					<cell>pass</cell>
					<cell>pass</cell>
					<cell>0.8*0.8*0.8=0.512</cell>
					<cell>3</cell>
				</row>
				<row>
					<cell>pass</cell>
					<cell>pass</cell>
					<cell>fail</cell>
					<cell>0.8*0.8*0.2=0.128</cell>
					<cell>2</cell>
				</row>
				<row>
					<cell>pass</cell>
					<cell>fail</cell>
					<cell>pass</cell>
					<cell>0.8*0.2*0.8=0.128</cell>
					<cell>2</cell>
				</row>
				<row>
					<cell>pass</cell>
					<cell>fail</cell>
					<cell>fail</cell>
					<cell>0.8*0.2*0.2=0.032</cell>
					<cell>1</cell>
				</row>
				<row>
					<cell>fail</cell>
					<cell>pass</cell>
					<cell>pass</cell>
					<cell>0.2*0.8*0.8=0.128</cell>
					<cell>2</cell>
				</row>
				<row>
					<cell>fail</cell>
					<cell>pass</cell>
					<cell>fail</cell>
					<cell>0.2*0.8*0.2=0.032</cell>
					<cell>1</cell>
				</row>
				<row>
					<cell>fail</cell>
					<cell>fail</cell>
					<cell>pass</cell>
					<cell>0.2*0.2*0.8=0.032</cell>
					<cell>1</cell>
				</row>
				<row>
					<cell>fail</cell>
					<cell>fail</cell>
					<cell>fail</cell>
					<cell>0.2*0.2*0.2=0.008</cell>
					<cell>0</cell>
				</row>
				<row>
					<cell>Item 1</cell>
					<cell>Item 2</cell>
					<cell>Item 3</cell>
					<cell>probability</cell>
					<cell>X</cell>
				</row>
			</table>
			<table char_offset="378" col_max="120" col_min="40">
				<row>
					<cell>0</cell>
					<cell>0.008</cell>
				</row>
				<row>
					<cell>1</cell>
					<cell>0.096</cell>
				</row>
				<row>
					<cell>2</cell>
					<cell>0.384</cell>
				</row>
				<row>
					<cell>3</cell>
					<cell>0.512</cell>
				</row>
				<row>
					<cell>X</cell>
					<cell>Total Probability</cell>
				</row>
			</table>
			<table char_offset="762" col_max="120" col_min="40">
				<row>
					<cell>0</cell>
					<cell>0.008</cell>
				</row>
				<row>
					<cell>1</cell>
					<cell>0.104</cell>
				</row>
				<row>
					<cell>2</cell>
					<cell>0.488</cell>
				</row>
				<row>
					<cell>3</cell>
					<cell>1.00</cell>
				</row>
				<row>
					<cell>x</cell>
					<cell>F(x)</cell>
				</row>
			</table>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Random Variables" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1535639982.78" ts_lastsave="1535643930.24" unique_id="24">
				<rich_text>
Random Variable
• function that assigns real number to each outcome in a sample space
• denoted by capital letter
   ◇ use lower-case (same letter) to represent specific value of random variable

Types of R.V.
• discrete
   ◇ sample space is mutually exclusive
   ◇ non-continuous sample space
   ◇ usually result of something that is counted
• continuous

Function of a R.V.
• random variable X with mean μ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text> and std. deviation σ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text> and pmf f(x)
• new random Y -&gt; Y = aX+b
   ◇ mean for Y, first need probs for y
      ▪ P(Y = y) = P(X = x)
      ▪ μ</rich_text>
				<rich_text scale="sub">y</rich_text>
				<rich_text> = Σ y*f(y) = Σ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text> (ax + b) f(x) = Σ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text> axf(x) + Σ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text> b*f(x) = a * Σ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text>xf(x) + b*Σ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text>f(x) = a * μ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text> + b*1
   ◇ variance for Y
      ▪ σ</rich_text>
				<rich_text scale="sup">2</rich_text>
				<rich_text scale="sub">y</rich_text>
				<rich_text> = Σ</rich_text>
				<rich_text scale="sub">y</rich_text>
				<rich_text> (y - μ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text>)</rich_text>
				<rich_text scale="sup">2</rich_text>
				<rich_text>f(y) = Σ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text> [ax + b - (aμ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text>-b]</rich_text>
				<rich_text scale="sup">2</rich_text>
				<rich_text>f(x) = a</rich_text>
				<rich_text scale="sup">2</rich_text>
				<rich_text> Σ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text>(x - μ</rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text>)</rich_text>
				<rich_text scale="sup">2</rich_text>
				<rich_text>f(x) = a</rich_text>
				<rich_text scale="sup">2</rich_text>
				<rich_text>σ</rich_text>
				<rich_text scale="sup">2</rich_text>
				<rich_text scale="sub">x</rich_text>
			</node>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Distributions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536071443.71" ts_lastsave="1536677354.63" unique_id="28">
			<rich_text>
Common distributions
• uniform
• Bernoulli
   ◇ not important by itself
   ◇ basis of binomial, geometric, neg. binomail, and Poisson
• binomial
• geometric
• negative binomial
• Poisson


Uniform Distribution
• every outcome has the same probability
• if possible outcomes are x</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>, x</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text>, ... x</rich_text>
			<rich_text scale="sub">n</rich_text>
			<rich_text>
   ◇ P(X = x</rich_text>
			<rich_text scale="sub">i</rich_text>
			<rich_text>) = 1/n

Example
• X is the last digit of phone numbers
• X ~ uniform
• S = {0, 1, 2, ..., 9}
• f(x) = 1/10 = 0.10
• μ = Σ x</rich_text>
			<rich_text scale="sub">i</rich_text>
			<rich_text>f(x) = 1/10 * 45 = 4.5
• σ</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> = Σx</rich_text>
			<rich_text scale="sub">i</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> f(x</rich_text>
			<rich_text scale="sub">i</rich_text>
			<rich_text>) - (4.5)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> = 8.25
• Shortcut formulae for μ and σ</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> when X ~ uniform from ints a to b
   ◇ μ = (a + b)/2
   ◇ σ</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> = ((b - a + 1)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> - 1)/12


Bernoulli Trials
• two possible outcomes - Success and Failure
• P(success) = p
• P(failure) = 1 - p


Binomial Distribution
• repeat an identical Bernoulli trial n times
• X = number of successes
   ◇ S = {0, 1, 2, ..., n}
   ◇ pmf f(x) = (n C x) p</rich_text>
			<rich_text scale="sup">x</rich_text>
			<rich_text> (1 - p)</rich_text>
			<rich_text scale="sup">n-x</rich_text>
			<rich_text>
      ▪ n C x calculated as n! / (x! * (n-x)!))
   ◇ p is the probability of success on any one trial
      ▪ 0 &lt;= p &lt;= 1
      ▪ p is </rich_text>
			<rich_text style="italic">not</rich_text>
			<rich_text> part of the domain for the pmf function
      ▪ p is a parameter
   ◇ binomial expansion (a + b)</rich_text>
			<rich_text scale="sup">n</rich_text>
			<rich_text> = Σ</rich_text>
			<rich_text scale="sub">k=0</rich_text>
			<rich_text scale="sup">n</rich_text>
			<rich_text> (n C k) a</rich_text>
			<rich_text scale="sup">k</rich_text>
			<rich_text>b</rich_text>
			<rich_text scale="sup">n-k</rich_text>
			<rich_text>
      ▪ substitute a = p and b = 1-p

Binomial Example
• red cross needs more O- blood, but only 7% have O-
   ◇ success = 0- blood, p = 0.07
   ◇ n = 50
   ◇ mean = np = 3.5
   ◇ variance = np (1-9) = 3.5*(0.93) = 3.255
   ◇ std. dev = √3.255 ~= 1.8


Geometric distribution
• Repeat Bernoulli trials until success is obtained
   ◇ trials must be independent
   ◇ p = prob of success
   ◇ X = num of trials until first success
      ▪ x - 1 = num of failures
• pmf
   ◇ f(x) = (1-p)</rich_text>
			<rich_text scale="sup">x-1</rich_text>
			<rich_text>*p
   ◇ x = {1, 2, 3, ....}
• mean = 1/p
• variance = (1-p)/p</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>


Negative Binomial distribution
• repeated Bernoulli trials
• continue until you have seen r successes
   ◇ X = # of trials
   ◇ if r = 1, x ~ geometric
• pmf
   ◇ f(x) = (x-1 C r-1) p</rich_text>
			<rich_text scale="sup">r</rich_text>
			<rich_text> (1-p)</rich_text>
			<rich_text scale="sup">x-r</rich_text>
			<rich_text>
   ◇ mean = μ = r/p
   ◇ variance = σ</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> = (r*(1-p))/p</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>


Poisson distribution
• No repeated Bernoulli trials
• X = # of successes in an interval
   ◇ can be space (# of structural failures in an area of an airplane wing)
   ◇ can be time
• T = size of interval
   ◇ parameter of function
• λ = mean number of successes in T
• S = {0,1,2,...}
• pmf = f(x) = (e</rich_text>
			<rich_text scale="sup">-λT</rich_text>
			<rich_text>(λT)</rich_text>
			<rich_text scale="sup">x</rich_text>
			<rich_text>)/x

Example
• X ~ poisson
• μ = 2.3 per mm =&gt; λ = 11.5 per 5 mm
   ◇ when units match, ignore T
• find probability of 10 flaws in 5 mm
• f(x) = (e</rich_text>
			<rich_text scale="sup">-λ</rich_text>
			<rich_text>(λ)</rich_text>
			<rich_text scale="sup">x</rich_text>
			<rich_text>)/x for x = 0,1,2,...</rich_text>
			<node custom_icon_id="0" foreground="" is_bold="False" name="Continuous Distributions" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1536677354.63" ts_lastsave="1536679389.21" unique_id="35">
				<rich_text>
• Actually uses calculus
• no pmf
   ◇ uses pdf instead
   ◇ probability </rich_text>
				<rich_text style="italic">density</rich_text>
				<rich_text> function
• requirements
   ◇ function f(x) &gt;= 0 for all x
   ◇ </rich_text>
				<rich_text scale="sub">-∞</rich_text>
				<rich_text>∫</rich_text>
				<rich_text scale="sup">∞</rich_text>
				<rich_text> f(x) dx = 1
   ◇ for continuous distributions, P(X == x) = 0
• calculations used
   ◇ P(X &lt;= x)
   ◇ P(X &gt;= x)
   ◇ P(x</rich_text>
				<rich_text scale="sub">1</rich_text>
				<rich_text> &lt;= X &lt;= x</rich_text>
				<rich_text scale="sub">2</rich_text>
				<rich_text>)


Example
• using ex 4.2 page 69
• X = diameter of a drilled hole
• f(x) = 20 * e</rich_text>
				<rich_text scale="sup">-20(x-12.5)</rich_text>
				<rich_text>
• Find P(X &gt; 12.6) = </rich_text>
				<rich_text scale="sub">12.6</rich_text>
				<rich_text>∫</rich_text>
				<rich_text scale="sup">∞</rich_text>
				<rich_text> 20 e</rich_text>
				<rich_text scale="sup">-20(x-12.6)</rich_text>
				<rich_text>
   ◇ = -e</rich_text>
				<rich_text scale="sup">-20(x-12.5)</rich_text>
				<rich_text>|</rich_text>
				<rich_text scale="sub">12.6</rich_text>
				<rich_text scale="sup">∞</rich_text>
				<rich_text> = -(0 - e</rich_text>
				<rich_text scale="sup">-20(12.6-12.5)</rich_text>
				<rich_text>) = e</rich_text>
				<rich_text scale="sup">-20(0.1)</rich_text>
				<rich_text> = 0.135


Finding probabilities
• cdf = cumulative density function
• F(x) = Pr(X &lt;= x) = </rich_text>
				<rich_text scale="sub">x</rich_text>
				<rich_text>∫</rich_text>
				<rich_text scale="sup">∞</rich_text>
				<rich_text> f(t) dt</rich_text>
			</node>
		</node>
	</node>
</cherrytree>
