<?xml version="1.0" ?>
<cherrytree>
	<node custom_icon_id="0" foreground="" is_bold="False" name="HIST251" prog_lang="plain-text" readonly="False" tags="" ts_creation="1548170769.18" ts_lastsave="1548170769.18" unique_id="1">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Jan 22" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1548170783.82" ts_lastsave="1548344330.02" unique_id="2">
			<rich_text>• need the book for McGraw Hill code
   ◇ 1-800-331-5094
   ◇ McGraw Hill support number
• Digital Syllabus online

Point Breakdown:
• 140 pts - weekly reading
• 105 pts - primary sources
• 100 pts - exam 1
• 100 pts - exam 2
• 100 pts - final exam
• 100 pts - final exam essay
• 645 pts - total

</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Jan 24" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1548344330.02" ts_lastsave="1548775698.47" unique_id="5">
			<rich_text>Previous historical records
• very biased
• ignore existence of native populations
• keep in mind who they're written by - the Europeans who landed here

Flora/Fauna
• pre-human North America had great species diversity
• climate is more like the sahara or serengeti
• many large/giant animal species
• horses were originally native to NA, but died off

First Humans in NA
• 35,000 - 50,000 years ago
• likely that some people arrived by boat before the Bering land bridge
• land bridge around 35k years ago
• around 10k years ago, domesticated crops created
   ◇ beans, squash, gourds first
   ◇ cotton, corn, pottery around 5k years ago
   ◇ early diets were heavy in corn, causing Niacin deficiencies
      ▪ natives didn't know what they were missing, but fixed with lime from stone

Olmecs
• “mother culture”
   ◇ 1900-1500 BCE
• create first cities
   ◇ leads to social heirarchies, leisure classes, art, etc.
   ◇ more specialization in roles
• created religious sites
   ◇ had distinct priest class

Mayans
• 750 BC
   ◇ last city conquered by the Spanish in 1697 CE
• first known heiroglyphic writing
   ◇ used to write codices with history and info about daily life
   ◇ many writings burned by the Spanish
• Came up with concept of 0
   ◇ incredibly important mathematical concept
   ◇ allows for large-scale math
• used calendar called Tzolkin

Aztecs
• 1325-1521 CE
• capital city called Tenochititlan
   ◇ rivals almost every Roman city built, but in less than 200 years
   ◇ used arches and aqueducts
• built floating terraces to grow food
• had several enemies
   ◇ large empires are rarely built entirely on peace

Inca
• 1438-1525 CE
• largest empire in pre-Colombian America
• built empire in mountains
   ◇ creates new challenges for agriculture and travel
   ◇ developed extensive roads and mountain farming systems
      ▪ over 12,000 miles of roads
• most artwork destroyed by Spanish

Continental US Natives
• Cahokia, IL - mound builders
   ◇ generic term
   ◇ culture lacked writing, hard to learn from
   ◇ may have been one group or multiple groups
• Mesa Verde, CO - Anasazi
   ◇ built houses into the sides of rock mesas
   ◇ used pictograms for writing
      ▪ not as precise as proper writing</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Exploration and Empire in South America" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1548775698.48" ts_lastsave="1549380735.33" unique_id="7">
			<rich_text>How did colonialism begin?
• </rich_text>
			<rich_text underline="single">colonialism</rich_text>
			<rich_text> - the conquest and control of other people's land and goods with ties to the parent state
• Out of the Ashes
   ◇ Plague (1347-1351)
      ▪ 60% death rate
• redistribution of wealth
   ◇ chinese gunpowder

Age of Exploration
• new technology makes sailing easier
   ◇ lanteen sails
• Portugal
   ◇ Prince Henry the Navigator
   ◇ Bartholomeu Dias
   ◇ Vasco de Gama
   ◇ Plantation systems
• Spain
   ◇ Rulers: Ferdinand and Isabella
   ◇ Christopher Colombus
      ▪ already knew that world is </rich_text>
			<rich_text underline="single">not</rich_text>
			<rich_text> flat
      ▪ thinks he can make it to India by going west
         - thought world is smaller than it really is
   ◇ Pope Alexander VI
      ▪ set demarcation lines to divide control between Spain and Portugal
      ▪ tells both nations to spread Catholicism

God, Gold, and Glory
• Cortes conquers Mexico, 1519-1521
• Pizarro conquers Peru, 1532-1534
• Queen Isabella funds expeditions
   ◇ King Ferdinand focused more on extracting wealth
   ◇ Queen had more focus on spreading Catholic beliefs
• Conquistadors
   ◇ motivated by stories of cities of gold
   ◇ gold was given as welcome gift or tribute
      ▪ tribes thought it owuld cause Spanish to go away
   ◇ Spanish thought there would be more gold available
   ◇ Encomienda system
      ▪ gift of land to particular conquistador once area has been conquered
      ▪ later became un-inheritable, removing motivation to care for land
         - much more limited time, want to take all they can
• Bartolome de Las Casas
   ◇ saddened by the current state of the conquest
      ▪ de Las Casas is more motivated by God, saddened by lust for gold
   ◇ becomes priest and tries to convert natives
   ◇ returns to Spain and asks for limits on how conquistadors can act
      ▪ Ferdinand disagrees
   ◇ Creates repartimiento system


Spain Superimposed
• conquest keeps going
   ◇ take over cities, temples, buildings, etc
   ◇ Incan road system already in place
• caste system created


Spain in North America
• bulk of Spanish influence is in southern regions
• Had some influence in continental US
   ◇ Florida (1513)
      ▪ established as military base
      ▪ ships could stop to resupply between Spain and Mexico
   ◇ New Mexico (1598)
      ▪ Acoma Pueblo
      ▪ natives tried to push back, Spanish responded more violently
• Assumed that people would stay after conquest


France: Fish, Fur, and Faith
• more commercial venture than Spanish
   ◇ most people coming through are explorers, traders, and trappers
• looking for Northwest Passage that will take people through North America
   ◇ still trying to get to the East Indies
• Developed “Middle Ground”
   ◇ alliance with Algonquin people
   ◇ mutual and reciprocal relationship
   ◇ French relied more on native guides
   ◇ intermarriage became common among French
      ▪ no French societies to emulate, often became part of indiginous populations
      ▪ would sometimes just go back to France and abandon native wives
• Much smaller population of explorers
   ◇ about 3000 people in entire Louisiana purchase and French Canada


Dutch Exploration
• Still looking for Northwest Passage
   ◇ led to fame of Henry Hudson, who explored the Hudson river
• New Amsterdam
   ◇ purchased rather than conquered
      ▪ paid native peoples in the area for the land
      ▪ probably didn't pay what the land was worth
   ◇ eventually sold to the Duke of York, became New York eventually
• Diverse settlement


Where were the English?
• most likely due to political and religious turmoil
• Mercantilism caused more turmoil
   ◇ balance of wealth in Europe was shifting dramatically


Dissent Abroad and Within
• England worried about spain
   ◇ commonly fight between the two nations
   ◇ both sides employed privateers
   ◇ Queen Elizabeth sends Sir Walter Raleigh
      ▪ searches for realm of El Dorado
• Defeat of Spanish Armada
   ◇ bad weather causes armada to go down
   ◇ Spain loses ability to defend itself

Founding Virginia
• Virginia company
   ◇ founded Jamestown in 1607
   ◇ created expedition of 104 settlers
      ▪ includes a lot of goldsmiths and jewelers
      ▪ majority men
• John Smith
• Powhatan Confederacy
• Pocahontas
   ◇ Disney movie presents it as love story between Pocahontas and John Smith
   ◇ Reality is different
      ▪ Pocahontas was likely around 11 or 12
      ▪ John Smith was closer to 30
      ▪ Possibly a setup by Powhatan to demonstrate mercy without losing power
• John Rolfe
   ◇ Pocahontas is contractually required to marry to earn freedom
      ▪ Pocahontas dies at age of 21-ish
      ▪ away from friends and family
      ▪ using the name “Rebecca”
   ◇ later introduces tobacco to Virginia
      ▪ the one resource England had that was sellable</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Models of Colonial Control" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1549380735.33" ts_lastsave="1549553340.51" unique_id="11">
			<rich_text>
Making a Living
• wasn't much incentive
   ◇ many people didn't live long
   ◇ tobacco farms needed workers
• Headright system
   ◇ would be given 50 acres per person
• Indentured servants
   ◇ passage to new world paid for
   ◇ eventually given land after working off debt
   ◇ essential to life in Chesapeake region
   ◇ not restricted by race, but by class
• Rough Living
   ◇ large disparity between upper and lower classes
      ▪ women were </rich_text>
			<rich_text style="italic">very</rich_text>
			<rich_text> uncommon
      ▪ Virginia Company starts paying women to come to the colonies
   ◇ roughly 80% of Jamestown settlers died
   ◇ easy to abuse intentured servitude
      ▪ masters could petition courts to extend your service


Puritan New England
• More religious motivation
   ◇ Persecution from Church of England
      ▪ believed that anyone can foster their own spiritual relationships
   ◇ more homogeneous in nature
      ▪ less mixing between social classes
      ▪ religious groups put community over individuals
• Natives
   ◇ Wampanoag
      ▪ hit by disease just before Puritans arrived
      ▪ much weaker fighting force
   ◇ Massasoit
      ▪ chief of Wampanoag
      ▪ willing to wait to see what the Puritans do
   ◇ Squanto
      ▪ had been captured by british settlers before
      ▪ sent to England as a slave, learns English language
      ▪ convinces English to send him home as a translator
• Large-scale migration
   ◇ entire community traveled together


Living as a Puritan
• Great Migration from 1629-1642
   ◇ total of ~21,000 pilgrims
   ◇ most in a very concentrated area
   ◇ took very few servants
• Bible Commonwealth
   ◇ “city upon a hill”
      ▪ trying to build a theocracy
      ▪ arguably less religious tolerance
   ◇ natural population builds due to whole families coming over
   ◇ John Withrop
      ▪ governor of Massachusetts
   ◇ most democratic of new world organizations
      ▪ required to be a man and a church member to vote
• Plain Style
   ◇ buildings, clothes, speech
      ▪ no stained glass, very few bright colors
      ▪ no extravagance
   ◇ extremely conservative gender roles
      ▪ very odd female baby names
         - patience, prudence, silence, fear, hope, BeFruitful
• Anne Hutchinson
   ◇ example of Puritan values in action
   ◇ arrives in 1634 at the age of 43
      ▪ well-educated, father was a clergyman
      ▪ had 15 children before arriving
   ◇ Antinomianism
      ▪ splinter sect of the Church
      ▪ goes against Predestination
         - teaches pre-grace (in a way)
      ▪ holds meetings in her home to teach others
         - rumors break out that she is hosting mixed-gender meetings
      ▪ eventually taken to trial
         - determined that she is radical and should be banished from the colony


Quakers
• Arrive in 1682
   ◇ Led by William Penn
   ◇ Also dissenting group from England
   ◇ original formed a group called the Friends
      ▪ believed that religious heirarchy wasn't necessary
         - refused to tip their hat to “higher” social/religious figures
      ▪ believed that all had the potential to lead their relationship
      ▪ known pacifists
   ◇ changed bartering practices
      ▪ wanted fixed rate for everyone
         - same price regardless of quantity or person


The Carolinas
• Originally one large chunk of land
• Land given to supporters of Charles II
• Had connection to Caribbean
   ◇ men from islands came to Carolinas
   ◇ brought slaves with them
      ▪ African majority (4x as many slaves as landowners)
      ▪ immediate fear of results
• </rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Uprisings and Social Hierarchies" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1549553340.52" ts_lastsave="1549985247.64" unique_id="12">
			<rich_text>
From Conversion to Massacre
• Christians believed they were more important
• “prayer towns”
   ◇ required to be Christian to stay in the town
   ◇ “converted” natives from their traditional lifestyle
   ◇ believed you couldn't be Christian and traditionally native
• Pequot Wars
   ◇ same area as Wampanoag
   ◇ trader in 1637 dies violently, nobody knows how or by whom
      ▪ Puritans decide Pequot were responsible w/ little evidence
      ▪ Men go to large city (Mystic) and light structures on fire
         - cause several hundred deaths
      ▪ Capture survivors, enslave them, send them away
   ◇ fall of Mystic opens large area for colonists
      ▪ remaining natives realized current life could be problematic


King Philip/Metacom's War (1676)
• Metacom
   ◇ chief of Wampanoag tribe
   ◇ son of Massasoit, leader who helped the Puritans upon arrival
   ◇ called “Philip” by colonists
   ◇ allies himself with other tribes
      ▪ try to force colonists out via guerilla warfare
• Raid of New England
   ◇ kill 5000 people
      ▪ didn't really care who was who
   ◇ dismember Metacom and put head on pike
   ◇ put survivors into slavery and sold to west indies


Bacon's Rebellion (1675)
• Bringing indentured servants over
   ◇ wealthy get 50 acres of land per servant
   ◇ long-term profit to pay for servants
   ◇ both European and African
      ▪ supposed to eventually free them
   ◇ people stopped dying of disease, survived long enough to end servitude
      ▪ causes too many people to come into the colonies
      ▪ creates an urban poor class
         - no land, but still want to work
• Nathaniel Bacon v. Sir William Berkeley
   ◇ Berkeley was governor of the area
      ▪ raised taxes to help English fight the Dutch
      ▪ trade goes down because of war
         - English forbidden to use Dutch ships, fewer ships available
   ◇ Nathanial Bacon
      ▪ young lawyer, related to governor
      ▪ assumes that he'll get land and a fortune when he comes over
      ▪ ends up at bottom of totem pole
      ▪ decides he wants a chance at success
   ◇ Revolt
      ▪ Bacon wants to become governor and make changes
      ▪ Berkeley can't use militia to clear new land
         - has economic and military reasons not to
      ▪ Bacon gathers lower class members, creates list of demands
      ▪ Berkeley refuses demands, revolt burns Jamestown to the ground
      ▪ Berkeley flees, Bacon acts as governor
         - Bacon dies of dysentery, Berkeley re-establishes control
         - revolt falls apart without Bacon as a focal point
• Repercussions
   ◇ slave status becomes inheritable
      ▪ if parent was slave, you're born as a slave
   ◇ African servants no longer freed
   ◇ White servants now given better chance
      ▪ distinction is no longer about class, but about race
   ◇ Fear of landless masses
      ▪ no real opportunities for males without land
         - failure viewed as solely your fault
         - women and children often taken care of
      ▪ no services like schools or charities, like Puritans in the north have


Pueblo Revolt (New Mexico, 1680)
• first successful uprising against colonization
• Popé
   ◇ captured by Spanish
   ◇ radicalized by the experience
   ◇ wants all Spanish out
      ▪ all animals, tools, etc
   ◇ builds coalition to fight against Spanish
      ▪ kill about 400 people
      ▪ push Spanish to El Paso for about 12 years


Growing Interest
• Charles II restored to power (1660)
   ◇ fighting within England and with Dutch is over
   ◇ more interest in trading outside of England
• Mercantilism
   ◇ idea that there is limited wealth in the world
• Navigational Acts (1660-1715)
   ◇ everything goes through London</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Colonial Life" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1549985247.65" ts_lastsave="1551195681.85" unique_id="14">
			<rich_text>
Impact of African Slave Trade
• slavery is not new to Americas
   ◇ formerly class was determined by class
• In Africa
   ◇ slaves had well-defined rights
      ▪ often POWs
      ▪ not slaves for life
      ▪ not transferable


Changes in the Law
• 1662: opens up slave women to bear burden of rape with benefits for slave owner
• 1667: baptism of slaves does not exempt them from bondage
• 1669: owners not punished for murder if they accidentally kill a slave through harsh punishment
• 1670: no negros nor indians can buy christian servants
• 1691: banish white man or woman who marries black, mulatto, or indian
• 1705: legal to dismember unruly slaves


Growth in the Colonies
• 1700: quarter-million people
   ◇ 1775: 2.5 million people
• most immigrants were not English
   ◇ Germans, French, Dutch made large part of population
• number of slaves doubled as well


Families
• few women remained unmarried
   ◇ problem with indentured servants
   ◇ indentured servants can't get married
• childbearing
   ◇ average of 8
   ◇ most frequent cause of death for women
• medicine
   ◇ 4 humors: yellow bile, black bile, blood, phlegm


Salem
• witch trials
   ◇ often thought of in a silly way today
   ◇ very dangerous time, especially for unmarried women
• absurd trials
   ◇ 4-year-old imprisoned
   ◇ 80-year-old woman also accused</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="The Revolution" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1551195681.85" ts_lastsave="1551800440.46" unique_id="17">
			<rich_text>
Crisis and Rebellion
• Olive Branch Petition (July 1775)
   ◇ want King George to stop listening to his ministers and talk with Congress
   ◇ Congress has approved an invasion into British Canada
   ◇ no response to the petition
      ▪ unknown if he read it and ignored it or not
• Thomas Paine's </rich_text>
			<rich_text style="italic">Common Sense</rich_text>
			<rich_text> (Jan 1776)
   ◇ government is a necessary evil
   ◇ evaluate a government by how well it keeps more evil parts of humanity in check
• Hessians (Aug 1776)
   ◇ arrived after signing of Declaration of Independence
   ◇ travel by boat takes time
      ▪ left before DoI was created
• Declaration of Independence


Articles of Confederation
• first constititution of the US (1777)
   ◇ envisioned similar to a congress
• anxious about centralized power
   ◇ voted on issues
   ◇ needed unanimous vote
• monetary problems
   ◇ men leave farms to fight the war
• republicanism
   ◇ as an idea or theory
   ◇ all power should come from the people being governed


Women in Wartime
• not officially allowed to join the army
• took up jobs in the cities
   ◇ protested the British soldiers being housed there
   ◇ stashed away supplies
• some followed the camps around
   ◇ provided laundry, clothes mending, etc.
   ◇ provided some medical help
   ◇ prostitution


Revolution and Native Peoples
• last chance to make a decision
   ◇ side with british and hope for better deal
   ◇ try to endear themselves to the colonists


Legacies of War
• Birth of a Nation
• Flight of loyalists
• George Washington
• Radical workings of republicanism</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="More Stuff" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1551800440.46" ts_lastsave="1551802827.52" unique_id="19">
			<rich_text>
Philadelphia Convention, 1787
• formed from desire for more structured government
• just after Shay's rebellion
   ◇ war veterans aren't getting paid
   ◇ have houses/farms forclosed on by the states
• mostly well-known figures, plus a farmer
   ◇ Ben Franklin, George Washington, etc.
   ◇ representatives of 13 colonies
• Changes to the Articles of Confederation
   ◇ James Madison - Virginia Plan
      ▪ articles are hopeless, need to start from scratch
      ▪ wants two houses in legislature
      ▪ “Lower House” votes determined by population
         - same as House of Reps. today
      ▪ people from lower house elected into “Upper House”
         - could leave smaller states without representation
      ▪ liked more by bigger states
   ◇ William Paterson - New Jersey Plan
      ▪ wants something similar to Articles
      ▪ one-house legislature
      ▪ same representation from each state
         - same as Senate today
      ▪ liked more by smaller states
• Compromise
   ◇ 2-house legislature that we have today
   ◇ Slavery?
      ▪ 3/5 compromise
      ▪ 6 slaves would count for 3 people
         - matters with </rich_text>
			<rich_text style="italic">representation and taxation</rich_text>
			<rich_text>
      ▪ only in the lower house, where votes are determined by representation


Federalism
• Anti-Federalists
   ◇ believed that republics should be small to avoid factions
   ◇ presidency seems to close to a King
   ◇ fear for states rights
   ◇ demanded there be listed individual rights
• Federalists
   ◇ Federalist Papers
      ▪ Alexander Hamilton, James Madison, John Jay
      ▪ “An Extended Republic”
         - actually better and more capable of controlling factions
      ▪ “Natural Aristocrats”
         - People rise according to merit
• Leads to Bill of Rights


Creating an Extended Republic
• George Washington
   ◇ inaugurated on April 30, 1789
   ◇ unanimous vote
   ◇ created a cabinet
      ▪ no explicit rules written about what is allowed
      ▪ creates Secretary of War, Treasury, etc.
• Alexander Hamilton
   ◇ Secretary of Treasury
• Whiskey Rebellion (1794)
   ◇ distillers taxed more
   ◇ hits small distributors harder
• National Bank

</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="CIS575" prog_lang="plain-text" readonly="False" tags="" ts_creation="1548275231.51" ts_lastsave="1548275231.51" unique_id="3">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Introduction" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1548275242.38" ts_lastsave="1548707832.88" unique_id="4">
			<rich_text>Specifications
• problem is specified with a contract
   ◇ given input satisfying a </rich_text>
			<rich_text style="italic">precondition</rich_text>
			<rich_text>
   ◇ given output satisfying a </rich_text>
			<rich_text style="italic">postcondition</rich_text>
			<rich_text>
• Example: informal contract (with x, y ints)
   ◇ return in y the square root of x
   ◇ Exercise: formalize this!

PRE: x &gt;= 0, x integer
POST: y</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> &lt;= x, y integer, (y+1)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> &gt; x, </rich_text>
			<rich_text strikethrough="true">y &gt;= 0</rich_text>
			<rich_text>
• y &gt;= 0 is made redundant by (y+1)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> &gt; x


Implementation
• the task of an algorithm
   ◇ described in a standard programming language
      ▪ no library functions
   ◇ uses osme time and space, which should be minimized
• Example: return in y the integer square root of x
   ◇ naive algorithm takes time proportional to y
   ◇ but exists algorithm based on binary search that takes time proportional to the logarithm of y


Sorting
• commonly-analyzed algorithm category
• has specification:
   ◇ PRE: Array A[1..n] of numbers
      ▪ or something with a total order
   ◇ POST: A[1..n] is non-decreasing
      ▪ ∀i ∀j (1 &lt;= i &lt;= j &lt;= n ⇒ A[i] &lt;= A[j])
      ▪ ∀i (1 &lt;= i &lt;= n-1) ⇒ A[i] &lt;= A[i+1]
• will see many sorting algorithms
   ◇ typically run in n lg(n)
   ◇ some run in time proportional to n
      ▪ if extra assumptions
   ◇ some run in time proportional to n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>

Selection
• specifications
   ◇ PRE: Array a[1..n] of numbers, k with k ∈ 1...n
   ◇ POST: return the kth smallest element of A
• Q: may A be modified?
   ◇ A1: No (default for specification)
   ◇ A2: yes, but only by permutation
• Q: what does “x is kth smallest” mean?
   ◇ there are (k-1) elements that are smaller than x


Top-Down Approach to Algorithms
• Reduction principle
   ◇ solve a problem by using a solution to a simpler problem
      ▪ break it down
• Simple top-down sorting
   ◇ may sort array A[1..n] as follows:
      ▪ if n &lt;= 1, then A[1..n] is already sorted


Recursive Insertion Sort
• PRE: A[1..n] is an array of numbers
• POST: A[1..n] is a permutation of its original values such that A[1..n] is non-decreasing
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• Notation for passing arrays as parameters:
   ◇ pointer to the array is passed
   ◇ boundaries are specified
• Need to specify InsertLast()
   ◇ PRE: A[1..n] with n &gt;= 1 is array of numbers such that A[1..n-1] is non-decreasing
   ◇ POST: A[1..n] is permutation of its original value s.t. A[1..n] is non-decreasing
• Space Usage
   ◇ when running, the stack grows to size at least proportional to n
   ◇ can limit performance as stack space is often limited


Bottom-up computation
• can save stack space by implementing a top-down design in bottom-up fashion
   1) compute solutions to smallest instance
   2) using top-down solution as guide, combine solutions of smaller instances to obtain solutions to larger instances
• fibonacci function
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ takes exponential time if computed naively
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
   ◇ “←” indicates value assignment to a value


Insertion Sort, Bottom-Up
• recall top-down version
   ◇ unfolds to InsertLast(A[1..2]) ... InsertLast(A[1..n])
• thus bottom-up version is:
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Insert Last Element in Proper Place
• PRE: A[1..n] with A[1..n-1] non-decreasing
• POST: A[1..n] is permutation of original values s.t. A[1..n] is non-decreasing
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Iterative Insertion Sort
• space use: constant amount of extra space is needed
   ◇ called </rich_text>
			<rich_text underline="single">in-place</rich_text>
			<rich_text>
• time use is:
   ◇ best case: linear, proportional to n
   ◇ worst case: quadratic, proportional to n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>
   ◇ average case: ???
      ▪ depends on expected input distribution</rich_text>
			<codebox char_offset="1939" frame_height="80" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">InsertionSort(A[1..n]):
    if n &gt; 1
        InsertionSort(A[1..n-1])
        InsertLast(A[1..n])</codebox>
			<codebox char_offset="2693" frame_height="45" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fib(0) = fib(1) = 1
fib(n+2) = fib(n) + fib(n+1)</codebox>
			<codebox char_offset="2745" frame_height="85" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">fib_iter(n):
    i,j ← n
    for k ← 1 to n - 1:
        i,j ← j, i+j
    return j</codebox>
			<codebox char_offset="2942" frame_height="55" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">InsertionSort(A[1..n])
    for i ← 2 to n
        InsertLast(A[1..i])</codebox>
			<codebox char_offset="3109" frame_height="85" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">InsertLast(A[1..n])
    if n &gt; 1 and A[n] &lt; A[n-1]
        A[n] ↔ A[n-1]
        InsertLast(A[1..n-1])</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Understanding Algorithms" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1548707832.88" ts_lastsave="1549312372.03" unique_id="6">
			<rich_text>Correctness Proofs
• people do not fully understand an algorithm until they are able to prove its correctness
• therefore, we shall
   ◇ design algorithms with correctness in mind

Correctness of Iterative Algorithms
• given loop invariant, must prove
   ◇ Initialization: invariant holds before first iteration
   ◇ maintenance: if invariant holds at beginning of an iteration, must also hold at end
   ◇ termination: the loop always exits
   ◇ correctness: loop invariant, together w/ exit condition, implies desired correctness property


Iterative InsertionSort
• still rely on InsertLast
• Specification:
   ◇ PRE: A[1..n]
   ◇ POST: A[1..n] s.t. it is non-decreasing
• Loop invariant: A[1..n] is a permutation of original values s.t. A[1..i-1] is non-decreasing

InsertionSort, Inner Loop
• Spec:
   ◇ PRE: A[1..n] is an array of numbers and i with 1 &lt;= i &lt;= n s.t. A[1..i-1] is non-decreasing
   ◇ POST: A[1..n] is permutation of original values s.t. A[1..i] is non-decreasing
• code:
   ◇ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• Tentative invariant:
   ◇ A[1..n] is permutation of original values
   ◇ A[1..j-1] and A[j..i] are both non-decreasing
• invariant does hold, and can show
   ◇ initialization
   ◇ correctness
   ◇ but </rich_text>
			<rich_text style="italic" underline="single">not</rich_text>
			<rich_text> maintenance
• invariant is too weak
• new invariant:
   ◇ A[1..n] is a permutation of its original values s.t. for all 1 &lt;= k &lt; k' &lt;= i, if k' != j then A[k] &lt;= A[k']


Correctness of Recursive Algorithms
• Want to prove correctness of recursive function
   ◇ called with arg of “size” n
• need to analyze the body
   ◇ to keep analysis manageable must be able to assume that each subcall gives correct result
   ◇ let i be the “size” of the arg to subcall
   ◇ then expect that i &lt; n
• can tgys aooeak ti mathematical induction

Recursive FindLast
• spec
   ◇ PRE: x ∈ A[1..n] (thus n &gt;= 1)
   ◇ POST: returns p ∈ 1..n: A[p] = x ∉ A[p + 1..n]
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Recursive InsertLast
• New prove correctness of InsertLast
• spec
   ◇ PRE: A[1..n] with n &gt;= 1 is array of numbers s.t. A[1..n-1] is non-decreasing
   ◇ POST: A[1..n] is a permutation of its original values s.t. it is non-decreasing
• </rich_text>
			<rich_text justification="left"></rich_text>
			<codebox char_offset="997" frame_height="63" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">j ← i
while j &gt; 1 and A[j] &lt; A[j - 1]:
    A[j] ↔ A[j-1]; j ← j-1</codebox>
			<codebox char_offset="1852" frame_height="90" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">FindLast(A,n,x)
    if A[n] = x
        return n
    else
        return FindLast(A,n-1,x)</codebox>
			<codebox char_offset="2091" frame_height="75" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">InsertLast(A[1..n])
    if n &gt; 1 and a[n] &lt; A[n-1]
        A[n] ↔ A[n-1]
        InsertLast(A[1..n-1])</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Asymptotic Notation" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1549312372.03" ts_lastsave="1549658982.13" unique_id="10">
			<rich_text>
What do we mean by Running Time?
• algorithm has running time f(n) may mean that
   ◇ for all inputs of “size” n, it takes at most f(n)
      ▪ thus f is upper bound
   ◇ for all inputs, it takes at least f(n)
      ▪ thus f is lower bound
   ◇ there exists some input of size n on which it takes time at least f(n)
      ▪ thus cannot get better upper bound than f(n)
   ◇ considering all inputs of size n, average time is f(n)
      ▪ requires probability distribution

Succinct Representation
• often calculate running time by some complex equation
   ◇ e.g. 4n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> + 7n + 8
• in the long run, what matters is the quadratic factor
   ◇ other parts of the equation rarely have a meaningful contribution in large sets
   ◇ will suffice to write O(n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>) or Θ(n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>)
• in the following we will only consider functions
   ◇ from natural numbers (# of bits in input)
   ◇ to non-negative real numbers (running time in ms, space use in MB, etc)
• our choices of unit do not matter

Big-O Notation
• definition:
   ◇ f ∈ O(g) iff exists c &gt; 0 and n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text> &gt;= 0 s.t. for all n with n &gt;= n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>, f(n) &lt;= cg(n)
   ◇ note: f is a function, O(g) is a </rich_text>
			<rich_text style="italic">set</rich_text>
			<rich_text> of functions
      ▪ is common abuse of notation to say f = O(g)
• interpretation:
   ◇ algorithm has running time in O(g) iff exists f ∈ O(g) s.t. for all n, and all input of size n, running time is at most f(n)
• threshold rule: in above definition, may omit the part concerning n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text> (assuming g is strictly positive)

Properties of O-relation
• relation “f ∈ O(g)” is
   ◇ reflexive: f ∈ O(f)
   ◇ transitive: if f ∈ O(g) and g ∈ O(h) then f ∈ O(h)

Limit Property
• A sufficient condition for f ∈ O(g) is that there exists c with 0 &lt;= c &lt; infinity s.t. lim(n-&gt;inf) { f(n)/g(n) } = c
• Ex: O(n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>) = O(4n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> + 7n + 9)
• a limit is not a necessary condition
   ◇ f(n) = 2</rich_text>
			<rich_text scale="sup">[lg n]</rich_text>
			<rich_text>; g(n) = 2</rich_text>
			<rich_text scale="sup">lg n</rich_text>
			<rich_text>

Big-Omega Notation
• dual to Big-O
   ◇ f ∈ Ω(g) iff g ∈ O(f)
• That is, f ∈ Ω(g) iff exists c &gt; 0 and n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text> s.t. for all n &gt;= n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>, g(n) &lt;= cf(n)

Interpretation of Ω Relation
• What does it mean that alg has running time in Ω(g)?
   ◇ all - there exists f ∈ Ω(g) s.t. for all n, and all input of size n, running time is at least f(n)
   ◇ some - exists f ∈ Ω(g) s.t. for all n there is some input (worst case) of size n s.t. running time is at least f(n)
• Is Insertion sort in Ω(n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>)?
   ◇ according to some (worst case), Yes
   ◇ according to all, No
• Insertion sort is always in Ω(n)


Big-Theta
• say that f ∈ Θ iff f ∈ O(g) and f ∈ Ω(g)
• That is, exists c</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>, c</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text> s.t. (from a certain point) f(n) is “sandwiched” between c</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>g(n) and c</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text>g(n)

Standard Usage
• will typically consider worst-case running time
• thus, Insertion sort is
   ◇ in Θ(n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>)
   ◇ in Ω(g)


Little-o, Little-omega
• Little-o: we say f ∈ o(g) iff for all real c &gt; 0 exists n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text> s.t. for all n with n &gt;= n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>, f(n) &lt; cg(n)
• Equivalently: f  ∈  o(g) iff
   ◇ lim(n-&gt;inf) { f(n) / g(n) } = 0
• says that f grows slower than g
• Little-omega: we say f ∈ ω(g) iff g ∈ o(f)

Comparisons
n</rich_text>
			<rich_text scale="sup">p</rich_text>
			<rich_text> ∈ X(n</rich_text>
			<rich_text scale="sup">q</rich_text>
			<rich_text>) iff p __ q
</rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>

Relating little-o to Big-O
• o(g) ⊆ O(g) \ Θ(g)
• </rich_text>
			<table char_offset="2985" col_max="120" col_min="40">
				<row>
					<cell>o</cell>
					<cell>&lt;</cell>
				</row>
				<row>
					<cell>O</cell>
					<cell>&lt;=</cell>
				</row>
				<row>
					<cell>Θ</cell>
					<cell>=</cell>
				</row>
				<row>
					<cell>Ω</cell>
					<cell>&gt;=</cell>
				</row>
				<row>
					<cell>ω</cell>
					<cell>&gt;</cell>
				</row>
				<row>
					<cell>X</cell>
					<cell>__</cell>
				</row>
			</table>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Analysis of Iterative Programs" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1549658982.13" ts_lastsave="1550092277.35" unique_id="13">
			<rich_text>
Outline
• will develop techniques for analyzing the running time of a program built w/ loops, conditionals, and assignments
   ◇ postponing recursion
   ◇ assume assignments take constant time
• agenda:
   ◇ motivate and state a general theorem that is widely applicable to (nested) loops


Analyze Loops by Estimating Sums
• running time of an iterative construct can be expressed as sum of the form sum(i=1 -&gt; g(n)) { f(i) }
   ◇ g(n) can be something like n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>
   ◇ f(i) is the function explicitly within the loop


Upper Estimates
• It is easy to see that T</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>(n) ∈ O(n</rich_text>
			<rich_text scale="sup">8</rich_text>
			<rich_text>)


Lower Estimates
• Upper asymptotic bounds are often also lower bounds
• Pitfall
   ◇ recall conjecture: sum(i=1 -&gt; g(n)) { f(i) ∈ Θ(g(n) * f(g(n))) }
   ◇ with g(n) = n and f(i) = 2</rich_text>
			<rich_text scale="sup">i</rich_text>
			<rich_text>


Smooth Functions
• a non-decreasing function f is smooth if there exists c and n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text> s.t. for all n (with n &gt;= n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>):
   ◇ f(2n) &lt;= cf(n)
   ◇ f(n) = n is smooth
   ◇ being smooth is closed under various operations, like addition and multiplication
• thus all polynomials are smooth (if positive coefficients)
   ◇ f(n) = 2</rich_text>
			<rich_text scale="sup">n</rich_text>
			<rich_text> is </rich_text>
			<rich_text underline="single">not</rich_text>
			<rich_text> smooth since f(2n) = 2</rich_text>
			<rich_text scale="sup">2n</rich_text>
			<rich_text> = (2</rich_text>
			<rich_text scale="sup">n</rich_text>
			<rich_text>)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> = f(n)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>


Key Result
• let X be O, Θ, or Ω.  Assume that T(n) = sum(i=1 -&gt; g(n)) { h(i) }
   ◇ where h ∈ X(f)
• can write T(n) ∈ sum(i=1 -&gt; g(n)) { X(f(i)) }
• if f is smooth (non-decreasing) then
   ◇ T(n) ∈ X(g(n) * f(g(n)))
• to apply, may need to rename so loop starts at 1


What is an Elementary Instruction
• recall iterative fibonacci function
   ◇ may naively think it runs in linear time
   ◇ in k'th iteration add Θ(k)-bit numbers so running time is rather Θ(n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>)
• for most programs can safely assume that assignments execute in constant time


Barometer Instructions
• executed that gets executed at least as often as any other instruction
   ◇ can be used to estimate total running time
   ◇ estimate number of times barometer instruction is executed</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Analysis of Recursive Programs" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1550092277.35" ts_lastsave="1550867153.56" unique_id="15">
			<rich_text>
Assume recursive calls have one less parameter:
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• if S</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>, S</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text> has cost h(n) then F has cost given by g(n) = h(n) + g(n-1)
• thus we get g(n) = sum(i=1 -&gt; n) { h(i) }
   ◇ we have seen how to handle this


Divide and Conquer Paradigm
• Spec:
   ◇ PRE: A[1..n] is array of numbers, n &gt;= 1
   ◇ POST: A[1..n] is sorted permutation of initial values
• </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>
• Merge:
   ◇ spec:
      ▪ PRE: A</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>, A</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text> are sorted arrays
      ▪ POST: returns sorted permutation of elements in A</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>, A</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text>
   ◇ Merge(A</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>[1..n</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>],A</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text>[1..n</rich_text>
			<rich_text scale="sub">2</rich_text>
			<rich_text>])
   ◇ running time: Θ(n) w.r.t. time and space
      ▪ MergeSort is not “in-place”
         - doesn't take constant space
   ◇ time recurrence
      ▪ T(n) ∈ 2T(n/2) + Θ(n)
      ▪ Solution: T(n) ∈ Θ(n lg n)
   ◇ space recurrence
      ▪ space can be reused
      ▪ S(n) ∈ S(n/2) + Θ(n)


Substitution Method
• address how to solve a recurrence such as T(n) &lt;= aT(n/b) + f(n)
   ◇ when n &lt; b then T(n) is a constant.
• may use substitution method
   ◇ guess the form of a solution
      ▪ T(n) &lt;= cg(n) with g as a specific function
   ◇ use mathematical induction to
      ▪ verify solution exists
      ▪ find suitable c
      ▪ establish T ∈ O(g)
• Ex 1
   ◇ T(n) &lt;= 2T(n/2) + n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>
   ◇ let us prove that T(n) ∈ O(n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>) by finding c &gt; - s.t. can prove T(n) &lt;= cn</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> for n &gt;= 1 by induction
      ▪ induction case: n &gt;= 2
         - 1 &lt;= floor(n/2) &lt; n
         - apply IH on floor(n/2)
      ▪ T(n) &lt;= 2T(floor(n/2)) + n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>
      ▪ IH &lt;= 2c*floor(n/2)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> + n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> &lt;= 2c(n/2)</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> + n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> &lt;= (c/2 +1)n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text> &lt;= cn</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>


General Recurrence Solving
• Master Theorem:
   ◇ given recurrence T(n) = aT(n/b) + f(n) for n &gt; n</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text>
   ◇ with
      ▪ b &gt;= 2 as an integer
      ▪ floor or ceiling around n/b
      ▪ T eventually non-decreasing
   ◇ with r=log</rich_text>
			<rich_text scale="sub">b</rich_text>
			<rich_text>a solutions are (X ∈ {O, Ω, Θ}


Intuition behind Master Theorem
• if T(n) = aT(n/b) + f(n) then
   ◇ T(n) = f(n) +aT(n/b) = f(n) + af(n/b) + a</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>T(n/b</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>) = f(n) + af(n/b) + a</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>T(n/b</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>) + ... + a</rich_text>
			<rich_text scale="sup">(logbn)</rich_text>
			<rich_text>
• if f ∈ Θ(n</rich_text>
			<rich_text scale="sup">q</rich_text>
			<rich_text>) then each term is a/b</rich_text>
			<rich_text scale="sup">q</rich_text>
			<rich_text> bigger than previous term


</rich_text>
			<codebox char_offset="51" frame_height="120" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">F(A[1..n])
    if n = 1
        return ...
    else
        S1
        F(A[1..n-1])
        S2</codebox>
			<codebox char_offset="351" frame_height="120" frame_width="320" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">MergeSort(A[1..n])
    if n &gt; 1
        m &lt;- [n/2]
        MergeSort(A[1..m])
        MergeSort(A[m+1..n])
        B[1..n] &lt;- Merge(A[1..m],A[m+1..n])
        Copy(B[1..n],A[1..n])</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Understanding Algorithms" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1550868362.66" ts_lastsave="1551472197.59" unique_id="16">
			<rich_text>
Dutch National Flag
• input: array of items, each having prop of red, white, or blue


Application in Selection Problem
• find the kth smallest element in A, let
   ◇ p be some element in A
   ◇ those elements smaller than p be red
   ◇ those elems == to p be white
   ◇ elems larger than p be blue
• dutch national flag finds r red elems, w white, and b blue
   ◇ if k &lt;= r, return kth smallest elem in red
   ◇ if k &gt; r+w, return k - r - wth smallest elem in blue partition


Top-down solution
• reduce instance of size n &gt; 0 to instance of size n - 1 by examining last item
   ◇ if it is blue, ignore it
   ◇ if it is blue, swap with first item and ignore it
   ◇ else:
      ▪ temporarily ignore it and solve remaining problem
      ▪ swap with first blue item, if there is one</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Graphs" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1551472197.59" ts_lastsave="1551904412.81" unique_id="18">
			<rich_text>
Basic Concepts
• directed graph G consists of
   ◇ vertices (V), also called nodes
   ◇ edges (E) where an edge
      ▪ goes from source node
      ▪ goes to a target node (which may equal the source)
      ▪ may carry extra data (distance/weight)
• No multigraphs:
   ◇ two distinct edges cannot have same source and target
• Path (of length n) from u</rich_text>
			<rich_text scale="sub">0</rich_text>
			<rich_text> to u</rich_text>
			<rich_text scale="sub">n</rich_text>
			<rich_text> is a sequence of edges
• size of graph is measured as
   ◇ n, number of nodes (|V|)
   ◇ a, number of edges (|E|)
      ▪ 0 &lt;= a &lt;= n</rich_text>
			<rich_text scale="sup">2</rich_text>
			<rich_text>


Undirected graphs
• similar to directed, except
   ◇ edges do not have direction
   ◇ no self-loops
• edge is now between two different nodes
   ◇ now 0 &lt;= a &lt;= n*(n-1)


Cycles
• for directed graph, a cycle is
   ◇ path of length &gt;= 1 from a node to itself
• given directed acyclic graph (DAG), is possible to find topological sort of the nodes
   ◇ a numbering u</rich_text>
			<rich_text scale="sub">1</rich_text>
			<rich_text>, ... u</rich_text>
			<rich_text scale="sub">n</rich_text>
			<rich_text> of the nodes s.t.
   ◇ if there is an edge from u</rich_text>
			<rich_text scale="sub">i</rich_text>
			<rich_text> to u</rich_text>
			<rich_text scale="sub">j</rich_text>
			<rich_text> then i &lt; j
• for undirected graph, cycle consists of
   ◇ path between u and v, together with
   ◇ an edge between v and u that does not occur in that path


Connectivity
• for undirected graph, nodes u and v are connected if
   ◇ exists a path between u and v
• for a directed graph, nodes u and v are
   ◇ strongly connected if there exists a path from u to v </rich_text>
			<rich_text weight="heavy">and</rich_text>
			<rich_text> a path from v to u
   ◇ connected if there exists a path from u to v </rich_text>
			<rich_text weight="heavy">or</rich_text>
			<rich_text> a path from v to u
   ◇ weakly connected if u and v are connected in the corresponding undirected graph
   ◇ we say that G is (strongly) connected if al u, v ∈ G are (strongly) connected


Trees
• undirected graph is called a tree if it is
   ◇ connected
   ◇ acyclic
• often identify a non-empty tree w/ its root node
   ◇ each tree node but the root has exactly one parent
   ◇ all tree nodes have root as ancestor
   ◇ a leaf is a node where all children are empty
   ◇ in binary trees, all nodes have exactly two children


Distance Metrics in Rooted Trees
• for a rooted tree T, may define distance from T to any subtree of T:
   ◇ distance from T to itself is 0
   ◇ distance from T to child of T is 1
   ◇ distance from T to child of a child of T is 2, etc.
• given tree T, for non-empty nodes q in T we define
   ◇ Depth(q): distance from root to q
   ◇ Height(q): maximal distance from q to a leaf
• nodes w/ same depth are said to be at same level


Basic operations
• representation of graphs must allow following operations:
• Get(i,j)
   ◇ checks whether there is an edge from i to j, if so it also returns any extra data
• Put(i,j,x)
   ◇ adds edge from i to j, together with extra data x
   ◇ if edge from i to j exists, may choose to require an error message
• AllFrom(i)
   ◇ returns list of edges with source i


Adjacency Matrix Implementation
• representation choice:
   ◇ Adjacency Matrix where entry at row i and column j specifies whether there is an edge from i to j (and contians any extra data)
   ◇ get runs in time Θ(1)
   ◇ put runs in time Θ(1)
   ◇ AllFrom runs in time Θ(n) (even in best case
• adjacency list
   ◇ to each i associates a list of nodes j (w/ extra data) s.t. there is an edge from i to j
   ◇ Get(i, _) runs in time Θ(n)
      ▪ in worst case where i has many neighbors
   ◇ Put runs in time Θ(1)
      ▪ Θ(n) if check for duplicates
   ◇ AllFrom runs in time Θ(1)
      ▪ simply return list at j
• Trade-offs
   ◇ Drawback of adjacency lists:
      ▪ occurs if graph is dense
         - Get will be Θ(n)
   ◇ drawback of adjacency matrix
      ▪ occurs if graph is sparse</rich_text>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Heaps" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1551904412.81" ts_lastsave="1552079348.18" unique_id="20">
			<rich_text>
Priority Queues
• A priority queue
   ◇ is a collection of records with keys
   ◇ allows following operations:
      ▪ insert: a record is added to the collection
      ▪ FindMax: record with highest key is returned
      ▪ DeleteMax: record with highest key is deleted from collection


Priority Queues by Arrays
• if implemented by unsorted array:
   ◇ Insert ∈ Θ(1)
   ◇ Find/DeleteMax
• if implemented by sorted array:
   ◇ Find/DeleteMax ∈ Θ(1)
   ◇ Insert ∈ Θ(n)
• need better option, with all operations sub-linear


The Heap Property
• A heap is a rooted tree that satisfies the heap property:
   ◇ if q is a child of p then K(p) &gt;= K(q)
• Thus parents have key sat least as big as their children
   ◇ sometimes we want the </rich_text>
			<rich_text style="italic">dual</rich_text>
			<rich_text> property instead
   ◇ don't confuse with garbage-collected memory (Java)


Heap Property Maintenance: Sift Down
• Heap property may be violated if the key of a node n decreases
   ◇ then have to “sift down” n
• Sift Down:
   ◇ while n has child with bigger key
      ▪ swap n and child with biggest key
• worst case running time in Θ(h) with h as the tree height


Heap Property Maintenance: Percolate Up
• Heap property may be violated if the key of a node n increases
   ◇ have to “percolate” n
• Percolate Up:
   ◇ while n has parent with smaller key:
      ▪ swap n and parent
• Worst case running time in Θ(h) with h as tree height


Priority Queues by Heaps
• with heap implementation:
   ◇ FindMax: just take root, this is Θ(1)
   ◇ Insert:
      ▪ insert new node as a leaf
      ▪ percolate leaf up
      ▪ This is in Θ(h)
   ◇ DeleteMax:
      ▪ move one leaf to the root


Representation of Heaps
• use rooted trees that are binary and
   ◇ essentially complete
      ▪ balanced, except that some rightmost leaves may be missing
• can use an array A to represent an essentially complete binary tree
   ◇ if it has k elements then A[1..k] are used
      ▪ A[1] is root
      ▪ A[2] and A[3] are left and right children of root,
      ▪ A[4..7] grandchildren of root, etc
   ◇ in general, can easily compute:
      ▪ Parent(i) = [i/2]
      ▪ leftchild(i) = 2i
      ▪ rightchild(i) = 2i + 1


Converting a Tree into a Heap
• given an essentiall complete binary tree we want to:
   ◇ convert it into a heap
   ◇ use node-swapping only
• Method:
   ◇ for each node
      ▪ recursively convert children into heaps
      ▪ sift down the node
   ◇ can be implemented bottom-up by processing the array downwards:
      ▪ </rich_text>
			<rich_text justification="left"></rich_text>
			<rich_text>


Cost of Heap Conversion, Attempt 1
• recall method for each node
   ◇ cost: sum(i = 1 -&gt; n) { O(height(i)) }
   ◇ crude approximation: n lg(n)
   ◇ tentative recurrence: T(n) = 2T(n/2) + lg(n)
      ▪ has solution T(n) ∈ Θ(lg(n))
      ▪ one subtree may be larger than the other, so not as accurate


Heap Sort
• Given array A[1..n] to be sorted we
   ◇ convert to heap
   ◇ let i traverse from n down to 1 while maintaining invariant
      ▪ A[i+1..n] consists of th en-i largest elements, in non-decreasing order
      ▪ A[1..i] has the heap property
      ▪ can be done as follows:
         - exchange A[1] and A[i]
         - sift down A[1] in tree A[1..i-1]

Complexity of Heap Sort
• Recall that to sort an array of n elements, we
   ◇ convert to heap, in time Θ(n)
   ◇ for i from n down to 1:
      ▪ exchange A[1] and A[i], in time Θ(1)
      ▪ Sift down A[1] in heap A[1..i] in time Θ(lg(i))
   ◇ contributes sum(i=1 to n) {lg(i)}
      ▪ which we know is in Θ(n lg(n))
• thus heap sort has
   ◇ time complexity in Θ(n lg(n)) which improves insertion sort
   ◇ space complexity in Θ(1), i.e. in place
      ▪ improves merge-sort


</rich_text>
			<codebox char_offset="2463" frame_height="60" frame_width="170" highlight_brackets="True" show_line_numbers="False" syntax_highlighting="plain-text" width_in_pixels="True">Convert(A[1..n]
    for i &lt;- n downto 1
        sift(i)</codebox>
		</node>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Divide and Conquer" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1552079348.18" ts_lastsave="1552079742.14" unique_id="21">
			<rich_text>
D&amp;C template
• given: problem of size n
• goal: compute f(x) with f some function
• method: divide and conquer
• if n is sufficiently big, we
   ◇ decompose into smaller problems
   ◇ recursively compute solutions
   ◇ recombine into solution y=f(x)3


Merge Sort
• follows D&amp;C
   ◇ decompose cuts array in half
   ◇ recombine merges two sorted arrays
• spec
   ◇ Merge has running time in Θ(n)
   ◇ MergeSort has running time in Θ</rich_text>
		</node>
	</node>
	<node custom_icon_id="0" foreground="" is_bold="False" name="CIS598" prog_lang="plain-text" readonly="False" tags="" ts_creation="1549312135.84" ts_lastsave="1549312135.84" unique_id="8">
		<rich_text></rich_text>
		<node custom_icon_id="0" foreground="" is_bold="False" name="Project Ideas" prog_lang="custom-colors" readonly="False" tags="" ts_creation="1549312306.02" ts_lastsave="1549317713.47" unique_id="9">
			<rich_text>
RPi Cluster
• Use Zeroes with OTG networking
   ◇ have to script the config changes before booting SD cards
      ▪ use udisks to detect new SD card?
   ◇ set up DNS and DHCP entries for each Pi
• running services
   ◇ ask if DNS/DHCP on Zeroes or Pi3
   ◇ ask if want k8s or Docker Swarm
• updates
   ◇ automated updates if desired
   ◇ simultaneous updates using tmux script
   ◇ ansible?
• job scheduling?
   ◇ check for k8s and docker capabilities
   ◇ use something similar to slurm
      ▪ Check Apache Mesos
         - </rich_text>
			<rich_text link="webs https://mesos.apache.org">https://mesos.apache.org</rich_text>
		</node>
	</node>
</cherrytree>
